<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Suffix (irmin-pack.Irmin_pack_unix.Dispatcher.S.Fm.Suffix)</title><link rel="stylesheet" href="../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../index.html">irmin-pack</a> &#x00BB; <a href="../../../../index.html">Irmin_pack_unix</a> &#x00BB; <a href="../../../index.html">Dispatcher</a> &#x00BB; <a href="../../index.html">S</a> &#x00BB; <a href="../index.html">Fm</a> &#x00BB; Suffix</nav><header class="odoc-preamble"><h1>Module <code><span>Fm.Suffix</span></code></h1><p>Abstraction for irmin-pack's append only files (i.e. suffix and dict).</p><p>It is parameterized with <code>Io</code>, a file system abstraction (e.g. unix, mirage, eio_linux).</p><p>It comprises a persistent file, an append buffer and take care of automatically shifting offsets to deal with legacy file headers.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-Io" class="anchored"><a href="#module-Io" class="anchor"></a><code><span><span class="keyword">module</span> Io</span><span> = <a href="../Io/index.html">Io</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-create_rw" class="anchored"><a href="#val-create_rw" class="anchor"></a><code><span><span class="keyword">val</span> create_rw : 
  <span>path:string <span class="arrow">&#45;&gt;</span></span>
  <span>overwrite:bool <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_threshold:int <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_callback:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-t">t</a>, <span>[&gt; <a href="../Io/index.html#type-create_error">Io.create_error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Create a rw instance of <code>t</code> by creating the file at <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-open_rw" class="anchored"><a href="#val-open_rw" class="anchor"></a><code><span><span class="keyword">val</span> open_rw : 
  <span>path:string <span class="arrow">&#45;&gt;</span></span>
  <span>end_offset:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span>dead_header_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_threshold:int <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_callback:<span>( <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-t">t</a>,
    <span>[&gt; <a href="../Io/index.html#type-open_error">Io.open_error</a>
    <span>| `Closed</span>
    <span>| `Invalid_argument</span>
    <span>| `Read_out_of_bounds</span>
    <span>| `Inconsistent_store</span> ]</span> )</span>
    <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Create a rw instance of <code>t</code> by opening an existing file at <code>path</code>.</p><p>End Offset</p><p>The file has an end offset at which new data will be saved. While this information could be computed by looking at the size of the file, we prefer storing that information elsewhere (i.e. in the control file). This is why <code>open_rw</code> and <code>open_ro</code> take an <code>end_offset</code> parameter, and also why <code>refresh_end_offset</code> exists. The abstractions above <code>Append_only_file</code> are responsible for reading/writing the offsets from/to the control file.</p><p><code>dead_header_size</code></p><p>Designates a small area at the beginning of the file that should be ignored. The offsets start after that area.</p><p>The actual persisted size of a file is <code>end_offset + dead_header_size</code>.</p><p>This concept exists in order to keep supporting <code>`V1</code> and <code>`V2</code> pack stores with <code>`V3</code>.</p><p>Auto Flushes</p><p>One of the goals of the <code>Append_only_file</code> abstraction is to provide buffered appends. <code>auto_flush_threshold</code> is the soft cap after which the buffer should be flushed. If a call to <code>append_exn</code> fills the buffer, <code>auto_flush_callback</code> will be called so that the parent abstraction takes care of the flush procedure, which is expected to call <code>flush</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-open_ro" class="anchored"><a href="#val-open_ro" class="anchor"></a><code><span><span class="keyword">val</span> open_ro : 
  <span>path:string <span class="arrow">&#45;&gt;</span></span>
  <span>end_offset:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span>dead_header_size:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <a href="#type-t">t</a>,
    <span>[&gt; <a href="../Io/index.html#type-open_error">Io.open_error</a>
    <span>| `Closed</span>
    <span>| `Inconsistent_store</span>
    <span>| `Invalid_argument</span>
    <span>| `Read_out_of_bounds</span> ]</span> )</span>
    <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Create a ro instance of <code>t</code> by opening an existing file at <code>path</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-close" class="anchored"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( unit, <span>[&gt; <a href="../Io/index.html#type-close_error">Io.close_error</a> <span>| `Pending_flush</span> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Close the underlying file.</p><p>The internal buffer is expected to be in a flushed state when <code>close</code> is called. Otherwise, an error is returned.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-end_offset" class="anchored"><a href="#val-end_offset" class="anchor"></a><code><span><span class="keyword">val</span> end_offset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Optint</span>.Int63.t</span></code></div><div class="spec-doc"><p><code>end_offset t</code> is the number of bytes of the file. That function doesn't perform IO.</p><p>RW mode</p><p>It also counts the bytes not flushed yet.</p><p>RO mode</p><p>This information originates from the latest reload of the control file. Calling <code>refresh_end_offset t</code> updates <code>end_offset</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-read_to_string" class="anchored"><a href="#val-read_to_string" class="anchor"></a><code><span><span class="keyword">val</span> read_to_string : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>off:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span>len:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>( string, <span>[&gt; <a href="../Io/index.html#type-read_error">Io.read_error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-read_exn" class="anchored"><a href="#val-read_exn" class="anchor"></a><code><span><span class="keyword">val</span> read_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>off:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>read_exn t ~off ~len b</code> puts the <code>len</code> bytes of <code>t</code> at <code>off</code> to <code>b</code>.</p><p><code>read_to_string</code> should always be favored over <code>read_exn</code>, except when performences matter.</p><p>It is not possible to read from an offset further than <code>end_offset t</code>.</p><p>Raises <code>Io.Read_error</code> and <code>Errors.Pack_error `Read_out_of_bounds</code>.</p><p>RW mode</p><p>Attempting to read from the append buffer results in an <code>`Read_out_of_bounds</code> error. This feature could easily be implemented in the future if ever needed. It was not needed with io_legacy.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-append_exn" class="anchored"><a href="#val-append_exn" class="anchor"></a><code><span><span class="keyword">val</span> append_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>append_exn t ~off b</code> writes <code>b</code> to the end of <code>t</code>. Might trigger an auto flush.</p><p>Grows <code>end_offset</code>, but the parent abstraction is expected to persist this somewhere (e.g. in the control file).</p><p>Post-condition: <code>end_offset t - end_offset (old t) = String.length b</code>.</p><p>Raises <code>Io.Write_error</code></p><p>RW mode</p><p>Always raises <code>Errors.RO_not_allowed</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-flush" class="anchored"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( unit, <span>[&gt; <a href="../Io/index.html#type-write_error">Io.write_error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Flush the append buffer. Does not call <code>fsync</code>.</p><p>RO mode</p><p>Always returns <code>Error `Ro_not_allowed</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fsync" class="anchored"><a href="#val-fsync" class="anchor"></a><code><span><span class="keyword">val</span> fsync : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( unit, <span>[&gt; <a href="../Io/index.html#type-write_error">Io.write_error</a> ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Tell the os to fush its internal buffers. Does not call <code>flush</code>.</p><p>RO mode</p><p>Always returns <code>Error `Ro_not_allowed</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-refresh_end_offset" class="anchored"><a href="#val-refresh_end_offset" class="anchor"></a><code><span><span class="keyword">val</span> refresh_end_offset : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>( unit, <span>[&gt; `Rw_not_allowed ]</span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Ingest the new end offset of the file. Typically happens in RO mode when the control file has been re-read.</p><p>RW mode</p><p>Always returns <code>Error `Rw_not_allowed</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-readonly" class="anchored"><a href="#val-readonly" class="anchor"></a><code><span><span class="keyword">val</span> readonly : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-auto_flush_threshold" class="anchored"><a href="#val-auto_flush_threshold" class="anchor"></a><code><span><span class="keyword">val</span> auto_flush_threshold : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty_buffer" class="anchored"><a href="#val-empty_buffer" class="anchor"></a><code><span><span class="keyword">val</span> empty_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-path" class="anchored"><a href="#val-path" class="anchor"></a><code><span><span class="keyword">val</span> path : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div></div></body></html>