<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Irmin (irmin.Irmin)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">irmin</a> &#x00BB; Irmin</nav><h1>Module <code>Irmin</code></h1><p>Irmin public API.</p><p><code>Irmin</code> is a library to design and use persistent stores with built-in snapshot, branching and reverting mechanisms. Irmin uses concepts similar to <a href="http://git-scm.com/">Git</a> but it exposes them as a high level library instead of a complex command-line frontend. It features a <em>bidirectional</em> Git backend, where an application can read and persist its state using the Git format, fully-compatible with the usual Git tools and workflows.</p><p>Irmin is designed to use a large variety of backends. It is written in pure OCaml and does not depend on external C stubs; it is thus very portable and aims to run everywhere, from Linux to browser and MirageOS unikernels.</p><p>Consult the <code>basics</code> and <a href="index.html#examples"><span>Examples</span></a> of use for a quick start. See also the <span class="xref-unresolved" title="unresolved reference to &quot;Irmin_unix&quot;"><span>documentation</span></span> for the unix backends.</p><p><em>Release 2.10.2 - %%HOMEPAGE%%</em></p><nav class="toc"><ul><li><a href="#preliminaries">Preliminaries</a></li><li><a href="#low-level-stores">Low-level Stores</a></li><li><a href="#user-defined-contents">User-Defined Contents</a></li><li><a href="#high-level-stores">High-level Stores</a><ul><li><a href="#synchronization">Synchronization</a></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#syncing-with-a-remote">Syncing with a remote</a></li><li><a href="#mergeable-logs">Mergeable logs</a></li></ul></li><li><a href="#helpers">Helpers</a></li><li><a href="#backend">Backends</a></li></ul></nav></header><dl><dt class="spec value" id="val-version"><a href="#val-version" class="anchor"></a><code><span class="keyword">val</span> version : string</code></dt><dd><p>The version of the library.</p></dd></dl><section><header><h2 id="preliminaries"><a href="#preliminaries" class="anchor"></a>Preliminaries</h2></header><dl><dt class="spec module" id="module-Type"><a href="#module-Type" class="anchor"></a><code><span class="keyword">module</span> Type = Repr</code></dt><dd><p>Dynamic types for Irmin values.</p></dd></dl><dl><dt class="spec module" id="module-Info"><a href="#module-Info" class="anchor"></a><code><span class="keyword">module</span> <a href="Info/index.html">Info</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Commit info are used to keep track of the origin of write operations in the stores. <code>Info</code> models the metadata associated with commit objects in Git.</p></dd></dl><dl><dt class="spec module" id="module-Merge"><a href="#module-Merge" class="anchor"></a><code><span class="keyword">module</span> <a href="Merge/index.html">Merge</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Merge</code> provides functions to build custom 3-way merge operators for various user-defined contents.</p></dd></dl><dl><dt class="spec module" id="module-Diff"><a href="#module-Diff" class="anchor"></a><code><span class="keyword">module</span> <a href="Diff/index.html">Diff</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Differences between values.</p></dd></dl><dl><dt class="spec type" id="type-diff"><a href="#type-diff" class="anchor"></a><code><span class="keyword">type</span> <span>'a diff</span></code><code> = <span><span class="type-var">'a</span> <a href="Diff/index.html#type-t">Diff.t</a></span></code></dt><dd><p>The type for representing differences betwen values.</p></dd></dl><dl><dt class="spec module" id="module-Perms"><a href="#module-Perms" class="anchor"></a><code><span class="keyword">module</span> <a href="Perms/index.html">Perms</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Types representing <i>permissions</i> <code>'perms</code> for performing operations on a certain type <code>'perms t</code>.</p></dd></dl></section><section><header><h2 id="low-level-stores"><a href="#low-level-stores" class="anchor"></a>Low-level Stores</h2></header><aside><p>An Irmin store is automatically built from a number of lower-level stores, each implementing fewer operations, such as <a href="module-type-CONTENT_ADDRESSABLE_STORE/index.html"><span>content-addressable</span></a> and <a href="module-type-ATOMIC_WRITE_STORE/index.html"><span>atomic-write</span></a> stores. These low-level stores are provided by various backends.</p></aside><dl><dt class="spec module-type" id="module-type-CONTENT_ADDRESSABLE_STORE"><a href="#module-type-CONTENT_ADDRESSABLE_STORE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-CONTENT_ADDRESSABLE_STORE/index.html">CONTENT_ADDRESSABLE_STORE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Content-addressable backend store.</p></dd></dl><dl><dt class="spec module-type" id="module-type-APPEND_ONLY_STORE"><a href="#module-type-APPEND_ONLY_STORE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-APPEND_ONLY_STORE/index.html">APPEND_ONLY_STORE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Append-only backend store.</p></dd></dl><dl><dt class="spec module-type" id="module-type-ATOMIC_WRITE_STORE"><a href="#module-type-ATOMIC_WRITE_STORE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ATOMIC_WRITE_STORE/index.html">ATOMIC_WRITE_STORE</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Atomic-write stores.</p></dd></dl></section><section><header><h2 id="user-defined-contents"><a href="#user-defined-contents" class="anchor"></a>User-Defined Contents</h2></header><dl><dt class="spec module" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span class="keyword">module</span> <a href="Path/index.html">Path</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Store paths.</p></dd></dl><dl><dt class="spec module" id="module-Hash"><a href="#module-Hash" class="anchor"></a><code><span class="keyword">module</span> <a href="Hash/index.html">Hash</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Hashing functions.</p></dd></dl><dl><dt class="spec module" id="module-Metadata"><a href="#module-Metadata" class="anchor"></a><code><span class="keyword">module</span> <a href="Metadata/index.html">Metadata</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Metadata</code> defines metadata that is attached to contents but stored in nodes. The Git backend uses this to indicate the type of file (normal, executable or symlink).</p></dd></dl><dl><dt class="spec module" id="module-Contents"><a href="#module-Contents" class="anchor"></a><code><span class="keyword">module</span> <a href="Contents/index.html">Contents</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Contents</code> specifies how user-defined contents need to be <em>serializable</em> and <em>mergeable</em>.</p></dd></dl><dl><dt class="spec module" id="module-Branch"><a href="#module-Branch" class="anchor"></a><code><span class="keyword">module</span> <a href="Branch/index.html">Branch</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>User-defined branches.</p></dd></dl><dl><dt class="spec type" id="type-remote"><a href="#type-remote" class="anchor"></a><code><span class="keyword">type</span> remote</code><code> = <a href="../Irmin__/S/index.html#type-remote">Irmin__.S.remote</a></code><code> = </code><code>..</code></dt><dd><p>The type for remote stores.</p></dd></dl><dl><dt class="spec type" id="type-config"><a href="#type-config" class="anchor"></a><code><span class="keyword">type</span> config</code><code> = <a href="../Irmin__/S/index.html#type-config">Irmin__.S.config</a></code></dt><dd><p>The type for backend-specific configuration values.</p><p>Every backend has different configuration options, which are kept abstract to the user.</p></dd></dl><dl><dt class="spec module" id="module-Private"><a href="#module-Private" class="anchor"></a><code><span class="keyword">module</span> <a href="Private/index.html">Private</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>Private</code> defines functions only useful for creating new backends. If you are just using the library (and not developing a new backend), you should not use this module.</p></dd></dl></section><section><header><h2 id="high-level-stores"><a href="#high-level-stores" class="anchor"></a>High-level Stores</h2><p>An Irmin store is a branch-consistent store where keys are lists of steps.</p><p>An example is a Git repository where keys are filenames, <em>i.e.</em> lists of <code>'/'</code>-separated strings. More complex examples are structured values, where steps might contain first-class field accessors and array offsets.</p><p>Irmin provides the following features:</p><ul><li>Support for fast clones, branches and merges, in a fashion very similar to Git.</li><li>Efficient staging areas for fast, transient, in-memory operations.</li><li>Fast <a href="Sync/index.html"><span>synchronization</span></a> primitives between remote stores, using native backend protocols (as the Git protocol) when available.</li></ul></header><dl><dt class="spec exception" id="exception-Closed"><a href="#exception-Closed" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Closed</span></code></dt><dd><p>The exception raised when any operation is attempted on a closed store, except for <span class="xref-unresolved" title="unresolved reference to &quot;S.close&quot;"><a href="index.html#module-type-S"><code>S</code></a>.close</span>, which is idempotent.</p></dd></dl><dl><dt class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Irmin stores.</p></dd></dl><div class="spec module" id="module-Json_tree"><a href="#module-Json_tree" class="anchor"></a><code><span class="keyword">module</span> <a href="Json_tree/index.html">Json_tree</a> : <a href="../Irmin__/Store/index.html#module-type-JSON_TREE">Irmin__.Store.JSON_TREE</a></code></div><dl><dt class="spec module-type" id="module-type-S_MAKER"><a href="#module-type-S_MAKER" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/index.html">S_MAKER</a> = <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-1-M/index.html">M</a> : <a href="Metadata/index.html#module-type-S">Metadata.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-2-C/index.html">C</a> : <a href="Contents/index.html#module-type-S">Contents.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-3-P/index.html">P</a> : <a href="Path/index.html#module-type-S">Path.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-4-B/index.html">B</a> : <a href="Branch/index.html#module-type-S">Branch.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-S_MAKER/argument-5-H/index.html">H</a> : <a href="Hash/index.html#module-type-S">Hash.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/index.html#type-key">key</a> = <a href="module-type-S_MAKER/argument-3-P/index.html#type-t">P.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/index.html#type-step">step</a> = <a href="module-type-S_MAKER/argument-3-P/index.html#type-step">P.step</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/index.html#type-metadata">metadata</a> = <a href="module-type-S_MAKER/argument-1-M/index.html#type-t">M.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/index.html#type-contents">contents</a> = <a href="module-type-S_MAKER/argument-2-C/index.html#type-t">C.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/index.html#type-branch">branch</a> = <a href="module-type-S_MAKER/argument-4-B/index.html#type-t">B.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/index.html#type-hash">hash</a> = <a href="module-type-S_MAKER/argument-5-H/index.html#type-t">H.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S_MAKER/Private/Sync/index.html#type-endpoint">Private.Sync.endpoint</a> = unit</code></dt><dd><p><code>S_MAKER</code> is the signature exposed by any backend providing <a href="module-type-S/index.html"><code>S</code></a> implementations. <code>M</code> is the implementation of user-defined metadata, <code>C</code> is the one for user-defined contents, <code>B</code> is the implementation for branches and <code>H</code> is the implementation for object (blobs, trees, commits) hashes. It does not use any native synchronization primitives.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KV"><a href="#module-type-KV" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KV/index.html">KV</a> = <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-KV/index.html#type-key">key</a> = <span>string list</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-KV/index.html#type-step">step</a> = string <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-KV/index.html#type-branch">branch</a> = string</code></dt><dd><p><code>KV</code> is similar to <a href="module-type-S/index.html"><code>S</code></a> but chooses sensible implementations for path and branch.</p></dd></dl><dl><dt class="spec module-type" id="module-type-KV_MAKER"><a href="#module-type-KV_MAKER" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KV_MAKER/index.html">KV_MAKER</a> = <span class="keyword">functor</span> (<a href="module-type-KV_MAKER/argument-1-C/index.html">C</a> : <a href="Contents/index.html#module-type-S">Contents.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-KV">KV</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-KV_MAKER/index.html#type-contents">contents</a> = <a href="module-type-KV_MAKER/argument-1-C/index.html#type-t">C.t</a></code></dt><dd><p><code>KV_MAKER</code> is like <a href="module-type-S_MAKER/index.html"><code>S_MAKER</code></a> but where everything except the contents is replaced by sensible default implementations.</p></dd></dl><section><header><h3 id="synchronization"><a href="#synchronization" class="anchor"></a>Synchronization</h3></header><dl><dt class="spec value" id="val-remote_store"><a href="#val-remote_store" class="anchor"></a><code><span class="keyword">val</span> remote_store : <span>(<span class="keyword">module</span> <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-t">t</a> = <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-remote">remote</a></code></dt><dd><p><code>remote_store t</code> is the remote corresponding to the local store <code>t</code>. Synchronization is done by importing and exporting store <span class="xref-unresolved" title="unresolved reference to &quot;BC.slice&quot;"><span>slices</span></span>, so this is usually much slower than native synchronization using <span class="xref-unresolved" title="unresolved reference to &quot;Store.remote&quot;"><code>Store</code>.remote</span> but it works for all backends.</p></dd></dl><dl><dt class="spec module-type" id="module-type-SYNC"><a href="#module-type-SYNC" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SYNC/index.html">SYNC</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>SYNC</code> provides functions to synchronize an Irmin store with local and remote Irmin stores.</p></dd></dl><dl><dt class="spec module" id="module-Sync"><a href="#module-Sync" class="anchor"></a><code><span class="keyword">module</span> <a href="Sync/index.html">Sync</a> : <span class="keyword">functor</span> (<a href="Sync/argument-1-S/index.html">S</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-SYNC">SYNC</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Sync/index.html#type-db">db</a> = <a href="Sync/argument-1-S/index.html#type-t">S.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Sync/index.html#type-commit">commit</a> = <a href="Sync/argument-1-S/index.html#type-commit">S.commit</a></code></dt><dd><p>The default <code>Sync</code> implementation.</p></dd></dl></section></section><section><header><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><p>These examples are in the <code>examples</code> directory of the distribution.</p></header><section><header><h4 id="syncing-with-a-remote"><a href="#syncing-with-a-remote" class="anchor"></a>Syncing with a remote</h4><p>A simple synchronization example, using the <span class="xref-unresolved" title="unresolved reference to &quot;Irmin_unix.Git&quot;"><span>Git</span></span> backend and the <a href="Sync/index.html"><code>Sync</code></a> helpers. The code clones a fresh repository if the repository does not exist locally, otherwise it performs a fetch: in this case, only the missing contents are downloaded.</p><pre><code class="ml">open Lwt.Infix
module S = Irmin_unix.Git.FS.KV (Irmin.Contents.String)
module Sync = Irmin.Sync (S)

let config = Irmin_git.config &quot;/tmp/test&quot;

let upstream =
  if Array.length Sys.argv = 2 then
    Uri.of_string (Store.remote Sys.argv.(1))
  else (
    Printf.eprintf &quot;Usage: sync [uri]\n%!&quot;;
    exit 1)

let test () =
  S.Repo.v config &gt;&gt;= S.master &gt;&gt;= fun t -&gt;
  Sync.pull_exn t upstream `Set &gt;&gt;= fun () -&gt;
  S.get t [ &quot;README.md&quot; ] &gt;|= fun r -&gt; Printf.printf &quot;%s\n%!&quot; r

let () = Lwt_main.run (test ())</code></pre></header></section><section><header><h4 id="mergeable-logs"><a href="#mergeable-logs" class="anchor"></a>Mergeable logs</h4><p>The complete code for the following can be found in <code>examples/custom_merge.ml</code>.</p><p>We will demonstrate the use of custom merge operators by defining mergeable debug log files. We first define a log entry as a pair of a timestamp and a message, using the combinator exposed by <a href="Type/index.html"><code>Irmin.Type</code></a>:</p><pre><code class="ml">open Lwt.Infix
open Astring

let time = ref 0L
let failure fmt = Fmt.kstr failwith fmt

(* A log entry *)
module Entry : sig
  include Irmin.Type.S

  val v : string -&gt; t
  val timestamp : t -&gt; int64
end = struct
  type t = { timestamp : int64; message : string } [@@deriving irmin]

  let compare x y = Int64.compare x.timestamp y.timestamp

  let v message =
    time := Int64.add 1L !time;
    { timestamp = !time; message }

  let timestamp t = t.timestamp

  let pp ppf { timestamp; message } =
    Fmt.pf ppf &quot;%04Ld: %s&quot; timestamp message

  let of_string str =
    match String.cut ~sep:&quot;: &quot; str with
    | None -&gt; Error (`Msg (&quot;invalid entry: &quot; ^ str))
    | Some (x, message) -&gt; (
        try Ok { timestamp = Int64.of_string x; message }
        with Failure e -&gt; Error (`Msg e))

  let t = Irmin.Type.like ~pp ~of_string ~compare t
end</code></pre><p>A log file is a list of entries (one per line), ordered by decreasing order of timestamps. The 3-way <code>merge</code> operator for log files concatenates and sorts the new entries and prepend them to the common ancestor's ones.</p><pre><code class="ml">(* A log file *)
module Log : sig
  include Irmin.Contents.S

  val add : t -&gt; Entry.t -&gt; t
  val empty : t
end = struct
  type t = Entry.t list [@@deriving irmin]

  let empty = []
  let pp_entry = Irmin.Type.pp Entry.t
  let lines ppf l = List.iter (Fmt.pf ppf &quot;%a\n&quot; pp_entry) (List.rev l)

  let of_string str =
    let lines = String.cuts ~empty:false ~sep:&quot;\n&quot; str in
    try
      List.fold_left
        (fun acc l -&gt;
          match Irmin.Type.of_string Entry.t l with
          | Ok x -&gt; x :: acc
          | Error (`Msg e) -&gt; failwith e)
        [] lines
      |&gt; fun l -&gt; Ok l
    with Failure e -&gt; Error (`Msg e)

  let t = Irmin.Type.like ~pp:lines ~of_string t
  let timestamp = function [] -&gt; 0L | e :: _ -&gt; Entry.timestamp e

  let newer_than timestamp file =
    let rec aux acc = function
      | [] -&gt; List.rev acc
      | h :: _ when Entry.timestamp h &lt;= timestamp -&gt; List.rev acc
      | h :: t -&gt; aux (h :: acc) t
    in
    aux [] file

  let merge ~old t1 t2 =
    let open Irmin.Merge.Infix in
    old () &gt;&gt;=* fun old -&gt;
    let old = match old with None -&gt; [] | Some o -&gt; o in
    let ts = timestamp old in
    let t1 = newer_than ts t1 in
    let t2 = newer_than ts t2 in
    let t3 =
      List.sort (Irmin.Type.compare Entry.t) (List.rev_append t1 t2)
    in
    Irmin.Merge.ok (List.rev_append t3 old)

  let merge = Irmin.Merge.(option (v t merge))
  let add t e = e :: t
end</code></pre><p><b>Note:</b> The serialisation primitives used in that example are not very efficient in this case as they parse the file every time. For real usage, you would write buffered versions of <code>Log.pp</code> and <code>Log.of_string</code>.</p><p>To persist the log file on disk, we need to choose a backend. We show here how to use the on-disk <code>Git</code> backend on Unix.</p><pre><code class="ml">(* Build an Irmin store containing log files. *)
module Store = Irmin_unix.Git.FS.KV (Log)

(* Set-up the local configuration of the Git repository. *)
let config = Irmin_git.config ~bare:true Config.root

(* Convenient alias for the info function for commit messages *)
let info = Irmin_unix.info</code></pre><p>We can now define a toy example to use our mergeable log files.</p><pre><code class="ml">let log_file = [ &quot;local&quot;; &quot;debug&quot; ]

let all_logs t =
  Store.find t log_file &gt;|= function None -&gt; Log.empty | Some l -&gt; l

(** Persist a new entry in the log. Pretty inefficient as it reads/writes
    the whole file every time. *)
let log t fmt =
  Printf.ksprintf
    (fun message -&gt;
      all_logs t &gt;&gt;= fun logs -&gt;
      let logs = Log.add logs (Entry.v message) in
      Store.set_exn t ~info:(info &quot;Adding a new entry&quot;) log_file logs)
    fmt

let print_logs name t =
  all_logs t &gt;|= fun logs -&gt;
  Fmt.pr &quot;-----------\n%s:\n-----------\n%a%!&quot; name (Irmin.Type.pp Log.t)
    logs

let main () =
  Config.init ();
  Store.Repo.v config &gt;&gt;= fun repo -&gt;
  Store.master repo &gt;&gt;= fun t -&gt;
  (* populate the log with some random messages *)
  Lwt_list.iter_s
    (fun msg -&gt; log t &quot;This is my %s &quot; msg)
    [ &quot;first&quot;; &quot;second&quot;; &quot;third&quot; ]
  &gt;&gt;= fun () -&gt;
  Printf.printf &quot;%s\n\n&quot; what;
  print_logs &quot;lca&quot; t &gt;&gt;= fun () -&gt;
  Store.clone ~src:t ~dst:&quot;test&quot; &gt;&gt;= fun x -&gt;
  log x &quot;Adding new stuff to x&quot; &gt;&gt;= fun () -&gt;
  log x &quot;Adding more stuff to x&quot; &gt;&gt;= fun () -&gt;
  log x &quot;More. Stuff. To x.&quot; &gt;&gt;= fun () -&gt;
  print_logs &quot;branch 1&quot; x &gt;&gt;= fun () -&gt;
  log t &quot;I can add stuff on t also&quot; &gt;&gt;= fun () -&gt;
  log t &quot;Yes. On t!&quot; &gt;&gt;= fun () -&gt;
  print_logs &quot;branch 2&quot; t &gt;&gt;= fun () -&gt;
  Store.merge_into ~info:(info &quot;Merging x into t&quot;) x ~into:t &gt;&gt;= function
  | Ok () -&gt; print_logs &quot;merge&quot; t
  | Error _ -&gt; failwith &quot;conflict!&quot;

let () = Lwt_main.run (main ())</code></pre></header></section></section><section><header><h2 id="helpers"><a href="#helpers" class="anchor"></a>Helpers</h2></header><dl><dt class="spec module" id="module-Dot"><a href="#module-Dot" class="anchor"></a><code><span class="keyword">module</span> <a href="Dot/index.html">Dot</a> : <span class="keyword">functor</span> (<a href="Dot/argument-1-S/index.html">S</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="Dot/index.html#module-type-S">Dot.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Dot/index.html#type-db">db</a> = <a href="Dot/argument-1-S/index.html#type-t">S.t</a></code></dt><dd><p><code>Dot</code> provides functions to export a store to the Graphviz `dot` format.</p></dd></dl></section><section><header><h2 id="backend"><a href="#backend" class="anchor"></a>Backends</h2><p>API to create new Irmin backends. A backend is an implementation exposing either a concrete implementation of <a href="module-type-S/index.html"><code>S</code></a> or a functor providing <a href="module-type-S/index.html"><code>S</code></a> once applied.</p><p>There are two ways to create a concrete <a href="module-type-S/index.html"><code>Irmin.S</code></a> implementation:</p><ul><li><a href="Make/index.html"><code>Make</code></a> creates a store where all the objects are stored in the same store, using the same internal keys format and a custom binary format based on <a href="https://github.com/janestreet/bin_prot">bin_prot</a>, with no native synchronization primitives: it is usually what is needed to quickly create a new backend.</li><li><a href="Make_ext/index.html"><code>Make_ext</code></a> creates a store with a <em>deep</em> embedding of each of the internal stores into separate store, with total control over the binary format and using the native synchronization protocols when available.</li></ul></header><dl><dt class="spec module-type" id="module-type-APPEND_ONLY_STORE_MAKER"><a href="#module-type-APPEND_ONLY_STORE_MAKER" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-APPEND_ONLY_STORE_MAKER/index.html">APPEND_ONLY_STORE_MAKER</a> = <span class="keyword">functor</span> (<a href="module-type-APPEND_ONLY_STORE_MAKER/index.html#argument-1-K">K</a> : <a href="index.html#module-Type">Type</a>.S) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-APPEND_ONLY_STORE_MAKER/index.html#argument-2-V">V</a> : <a href="index.html#module-Type">Type</a>.S) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>APPEND_ONLY_STORE_MAKER</code> is the signature exposed by append-only store backends. <code>K</code> is the implementation of keys and <code>V</code> is the implementation of values.</p></dd></dl><dl><dt class="spec module-type" id="module-type-CONTENT_ADDRESSABLE_STORE_MAKER"><a href="#module-type-CONTENT_ADDRESSABLE_STORE_MAKER" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-CONTENT_ADDRESSABLE_STORE_MAKER/index.html">CONTENT_ADDRESSABLE_STORE_MAKER</a> = <span class="keyword">functor</span> (<a href="module-type-CONTENT_ADDRESSABLE_STORE_MAKER/argument-1-K/index.html">K</a> : <a href="Hash/index.html#module-type-S">Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-CONTENT_ADDRESSABLE_STORE_MAKER/index.html#argument-2-V">V</a> : <a href="index.html#module-Type">Type</a>.S) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>CONTENT_ADDRESSABLE_STOREMAKER</code> is the signature exposed by content-addressable store backends. <code>K</code> is the implementation of keys and <code>V</code> is the implementation of values.</p></dd></dl><div class="spec module" id="module-Content_addressable"><a href="#module-Content_addressable" class="anchor"></a><code><span class="keyword">module</span> <a href="Content_addressable/index.html">Content_addressable</a> : <span class="keyword">functor</span> (<a href="Content_addressable/argument-1-S/index.html">S</a> : <a href="index.html#module-type-APPEND_ONLY_STORE_MAKER">APPEND_ONLY_STORE_MAKER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Content_addressable/argument-2-K/index.html">K</a> : <a href="Hash/index.html#module-type-S">Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Content_addressable/index.html#argument-3-V">V</a> : <a href="index.html#module-Type">Type</a>.S) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module-type" id="module-type-ATOMIC_WRITE_STORE_MAKER"><a href="#module-type-ATOMIC_WRITE_STORE_MAKER" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ATOMIC_WRITE_STORE_MAKER/index.html">ATOMIC_WRITE_STORE_MAKER</a> = <span class="keyword">functor</span> (<a href="module-type-ATOMIC_WRITE_STORE_MAKER/index.html#argument-1-K">K</a> : <a href="index.html#module-Type">Type</a>.S) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="module-type-ATOMIC_WRITE_STORE_MAKER/index.html#argument-2-V">V</a> : <a href="index.html#module-Type">Type</a>.S) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>ATOMIC_WRITE_STORE_MAKER</code> is the signature exposed by atomic-write store backends. <code>K</code> is the implementation of keys and <code>V</code> is the implementation of values.</p></dd></dl><dl><dt class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-CA/index.html">CA</a> : <a href="index.html#module-type-CONTENT_ADDRESSABLE_STORE_MAKER">CONTENT_ADDRESSABLE_STORE_MAKER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-2-AW/index.html">AW</a> : <a href="index.html#module-type-ATOMIC_WRITE_STORE_MAKER">ATOMIC_WRITE_STORE_MAKER</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S_MAKER">S_MAKER</a></code></dt><dd><p>Simple store creator. Use the same type of all of the internal keys and store all the values in the same store.</p></dd></dl><div class="spec module" id="module-Make_ext"><a href="#module-Make_ext" class="anchor"></a><code><span class="keyword">module</span> <a href="Make_ext/index.html">Make_ext</a> : <span class="keyword">functor</span> (<a href="Make_ext/argument-1-CA/index.html">CA</a> : <a href="index.html#module-type-CONTENT_ADDRESSABLE_STORE_MAKER">CONTENT_ADDRESSABLE_STORE_MAKER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-2-AW/index.html">AW</a> : <a href="index.html#module-type-ATOMIC_WRITE_STORE_MAKER">ATOMIC_WRITE_STORE_MAKER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-3-Metadata/index.html">Metadata</a> : <a href="Metadata/index.html#module-type-S">Metadata.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-4-Contents/index.html">Contents</a> : <a href="Contents/index.html#module-type-S">Contents.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-5-Path/index.html">Path</a> : <a href="Path/index.html#module-type-S">Path.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-6-Branch/index.html">Branch</a> : <a href="Branch/index.html#module-type-S">Branch.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-7-Hash/index.html">Hash</a> : <a href="Hash/index.html#module-type-S">Hash.S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-8-Node/index.html">Node</a> : <a href="../Irmin__/Node/index.html#module-type-S">Private.Node.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-metadata">metadata</a> = <a href="Make_ext/argument-3-Metadata/index.html#type-t">Metadata.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-hash">hash</a> = <a href="Make_ext/argument-7-Hash/index.html#type-t">Hash.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-step">step</a> = <a href="Make_ext/argument-5-Path/index.html#type-step">Path.step</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make_ext/argument-9-Commit/index.html">Commit</a> : <a href="../Irmin__/Commit/index.html#module-type-S">Private.Commit.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-hash">hash</a> = <a href="Make_ext/argument-7-Hash/index.html#type-t">Hash.t</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-key">key</a> = <a href="Make_ext/argument-5-Path/index.html#type-t">Path.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-contents">contents</a> = <a href="Make_ext/argument-4-Contents/index.html#type-t">Contents.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-branch">branch</a> = <a href="Make_ext/argument-6-Branch/index.html#type-t">Branch.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-hash">hash</a> = <a href="Make_ext/argument-7-Hash/index.html#type-t">Hash.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-step">step</a> = <a href="Make_ext/argument-5-Path/index.html#type-step">Path.step</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/index.html#type-metadata">metadata</a> = <a href="Make_ext/argument-3-Metadata/index.html#type-t">Metadata.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/Key/index.html#type-step">Key.step</a> = <a href="Make_ext/argument-5-Path/index.html#type-step">Path.step</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make_ext/Private/Sync/index.html#type-endpoint">Private.Sync.endpoint</a> = unit</code></div><dl><dt class="spec module" id="module-Of_private"><a href="#module-Of_private" class="anchor"></a><code><span class="keyword">module</span> <a href="Of_private/index.html">Of_private</a> : <span class="keyword">functor</span> (<a href="Of_private/argument-1-P/index.html">P</a> : <a href="Private/index.html#module-type-S">Private.S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-key">key</a> = <a href="Of_private/argument-1-P/Node/Path/index.html#type-t">P.Node.Path.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-contents">contents</a> = <a href="Of_private/argument-1-P/Contents/index.html#type-value">P.Contents.value</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-branch">branch</a> = <a href="Of_private/argument-1-P/Branch/index.html#type-key">P.Branch.key</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-hash">hash</a> = <a href="Of_private/argument-1-P/Hash/index.html#type-t">P.Hash.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-step">step</a> = <a href="Of_private/argument-1-P/Node/Path/index.html#type-step">P.Node.Path.step</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-metadata">metadata</a> = <a href="Of_private/argument-1-P/Node/Metadata/index.html#type-t">P.Node.Metadata.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/Key/index.html#type-step">Key.step</a> = <a href="Of_private/argument-1-P/Node/Path/index.html#type-step">P.Node.Path.step</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-repo">repo</a> = <a href="Of_private/argument-1-P/Repo/index.html#type-t">P.Repo.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Of_private/index.html#type-slice">slice</a> = <a href="Of_private/argument-1-P/Slice/index.html#type-t">P.Slice.t</a> <span class="keyword">and</span> <span class="keyword">module</span> <a href="Of_private/Private/index.html">Private</a> = <a href="Of_private/index.html#argument-1-P">P</a></code></dt><dd><p>Advanced store creator.</p></dd></dl><dl><dt class="spec module" id="module-Maker_ext"><a href="#module-Maker_ext" class="anchor"></a><code><span class="keyword">module</span> <a href="Maker_ext/index.html">Maker_ext</a> : <span class="keyword">functor</span> (<a href="Maker_ext/argument-1-CA/index.html">CA</a> : <a href="index.html#module-type-CONTENT_ADDRESSABLE_STORE_MAKER">CONTENT_ADDRESSABLE_STORE_MAKER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Maker_ext/argument-2-AW/index.html">AW</a> : <a href="index.html#module-type-ATOMIC_WRITE_STORE_MAKER">ATOMIC_WRITE_STORE_MAKER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Maker_ext/argument-3-Node/index.html">Node</a> : <a href="../Irmin__/Node/index.html#module-type-Maker">Private.Node.Maker</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Maker_ext/argument-4-Commit/index.html">Commit</a> : <a href="../Irmin__/Commit/index.html#module-type-Maker">Private.Commit.Maker</a>) <span>&#45;&gt;</span> <a href="../Irmin__/Store/index.html#module-type-Maker_future">Irmin__.Store.Maker_future</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Maker_ext/index.html#type-endpoint">endpoint</a> = unit</code></dt><dd><p>Exported for compatibility with a future version of Irmin.</p></dd></dl><dl><dt class="spec module" id="module-Export_for_backends"><a href="#module-Export_for_backends" class="anchor"></a><code><span class="keyword">module</span> <a href="Export_for_backends/index.html">Export_for_backends</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Helper module containing useful top-level types for defining Irmin backends. This module is relatively unstable.</p></dd></dl></section></div></body></html>