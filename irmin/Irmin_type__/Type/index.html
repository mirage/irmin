<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type (irmin.Irmin_type__.Type)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">irmin</a> &#x00BB; <a href="../index.html">Irmin_type__</a> &#x00BB; Type</nav><h1>Module <code>Irmin_type__.Type</code></h1><nav class="toc"><ul><li><a href="#type-combinators">Type Combinators</a></li><li><a href="#primitives">Primitives</a></li><li><a href="#records">Records</a></li><li><a href="#variants">Variants</a></li><li><a href="#recursive">Recursive definitions</a></li><li><a href="#generics">Generic Operations</a><ul><li><a href="#json-converters">JSON converters</a></li><li><a href="#binary-converters">Binary Converters</a></li></ul></li><li><a href="#customs-converters">Customs converters</a></li></ul></nav></header><aside><p>Yet-an-other type combinator library</p><p><code>Type</code> provides type combinators to define runtime representation for OCaml types and <a href="index.html#generics"><span>generic operations</span></a> to manipulate values with a runtime type representation.</p><p>The type combinators supports all the usual <a href="index.html#primitives"><span>type primitives</span></a> but also compact definitions of <a href="index.html#records"><span>records</span></a> and <a href="index.html#variants"><span>variants</span></a>. It also allows the definition of run-time representations of <a href="index.html#recursive"><span>recursive types</span></a>.</p></aside><section><header><h2 id="type-combinators"><a href="#type-combinators" class="anchor"></a>Type Combinators</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>The type for runtime representation of values of type <code>'a</code>.</p></dd></dl><dl><dt class="spec type" id="type-len"><a href="#type-len" class="anchor"></a><code><span class="keyword">type</span> len</code> = <code>[ </code><table class="variant"><tr id="type-len.Int" class="anchored"><td class="def constructor"><a href="#type-len.Int" class="anchor"></a><code>| </code><code>`Int</code></td></tr><tr id="type-len.Int8" class="anchored"><td class="def constructor"><a href="#type-len.Int8" class="anchor"></a><code>| </code><code>`Int8</code></td></tr><tr id="type-len.Int16" class="anchored"><td class="def constructor"><a href="#type-len.Int16" class="anchor"></a><code>| </code><code>`Int16</code></td></tr><tr id="type-len.Int32" class="anchored"><td class="def constructor"><a href="#type-len.Int32" class="anchor"></a><code>| </code><code>`Int32</code></td></tr><tr id="type-len.Int64" class="anchored"><td class="def constructor"><a href="#type-len.Int64" class="anchor"></a><code>| </code><code>`Int64</code></td></tr><tr id="type-len.Fixed" class="anchored"><td class="def constructor"><a href="#type-len.Fixed" class="anchor"></a><code>| </code><code>`Fixed <span class="keyword">of</span> int</code></td></tr></table><code> ]</code></dt><dd><p>The type of integer used to store buffers, list or array lengths.</p></dd></dl></section><section><header><h2 id="primitives"><a href="#primitives" class="anchor"></a>Primitives</h2></header><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span>unit <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>unit</code> is a representation of the unit type.</p></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span>bool <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>bool</code> is a representation of the boolean type.</p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : <span>char <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>char</code> is a representation of the character type.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <span>int <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int</code> is a representation of integers. Binary serialization uses a varying-width representation.</p></dd></dl><dl><dt class="spec value" id="val-int32"><a href="#val-int32" class="anchor"></a><code><span class="keyword">val</span> int32 : <span>int32 <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int32</code> is a representation of the 32-bit integer type.</p></dd></dl><dl><dt class="spec value" id="val-int64"><a href="#val-int64" class="anchor"></a><code><span class="keyword">val</span> int64 : <span>int64 <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>int64</code> is a representation of the 64-bit integer type.</p></dd></dl><dl><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : <span>float <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>float</code> is a representation of the <code>float</code> type.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>string</code> is a representation of the <code>string</code> type.</p></dd></dl><dl><dt class="spec value" id="val-bytes"><a href="#val-bytes" class="anchor"></a><code><span class="keyword">val</span> bytes : <span>bytes <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>bytes</code> is a representation of the <code>bytes</code> type.</p></dd></dl><dl><dt class="spec value" id="val-string_of"><a href="#val-string_of" class="anchor"></a><code><span class="keyword">val</span> string_of : <a href="index.html#type-len">len</a> <span>&#45;&gt;</span> <span>string <a href="index.html#type-t">t</a></span></code></dt><dd><p>Like <a href="index.html#val-string"><code>string</code></a> but with a given fixed size.</p></dd></dl><dl><dt class="spec value" id="val-bytes_of"><a href="#val-bytes_of" class="anchor"></a><code><span class="keyword">val</span> bytes_of : <a href="index.html#type-len">len</a> <span>&#45;&gt;</span> <span>bytes <a href="index.html#type-t">t</a></span></code></dt><dd><p>Like <a href="index.html#val-bytes"><code>bytes</code></a> but with a given fixed size.</p></dd></dl><dl><dt class="spec value" id="val-list"><a href="#val-list" class="anchor"></a><code><span class="keyword">val</span> list : <span>?&#8288;len:<a href="index.html#type-len">len</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> list</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>list t</code> is a representation of lists of values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-array"><a href="#val-array" class="anchor"></a><code><span class="keyword">val</span> array : <span>?&#8288;len:<a href="index.html#type-len">len</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> array</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>array t</code> is a representation of arrays of values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-option"><a href="#val-option" class="anchor"></a><code><span class="keyword">val</span> option : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> option</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>option t</code> is a representation of values of type <code>t option</code>.</p></dd></dl><dl><dt class="spec value" id="val-pair"><a href="#val-pair" class="anchor"></a><code><span class="keyword">val</span> pair : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>pair x y</code> is a representation of values of type <code>x * y</code>.</p></dd></dl><dl><dt class="spec value" id="val-triple"><a href="#val-triple" class="anchor"></a><code><span class="keyword">val</span> triple : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>triple x y z</code> is a representation of values of type <code>x * y * z</code>.</p></dd></dl><dl><dt class="spec value" id="val-result"><a href="#val-result" class="anchor"></a><code><span class="keyword">val</span> result : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> Stdlib.result</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>result a b</code> is a representation of values of type <code>(a, b) result</code>.</p></dd></dl><dl><dt class="spec type" id="type-empty"><a href="#type-empty" class="anchor"></a><code><span class="keyword">type</span> empty</code><code> = </code><table class="variant"></table></dt><dd><p>An uninhabited type, defined as a variant with no constructors.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><a href="index.html#type-empty">empty</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>empty</code> is a representation of the <a href="index.html#type-empty"><code>empty</code></a> type.</p></dd></dl></section><section><header><h2 id="records"><a href="#records" class="anchor"></a>Records</h2></header><dl><dt class="spec type" id="type-open_record"><a href="#type-open_record" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b, 'c) open_record</span></code></dt><dd><p>The type for representing open records of type <code>'a</code> with a constructor of type <code>'b</code>. <code>'c</code> represents the remaining fields to be described using the <a href="index.html#val-(|+)"><code>(|+)</code></a> operator. An open record initially satisfies <code>'c = 'b</code> and can be <a href="index.html#val-sealr"><span>sealed</span></a> once <code>'c = 'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-record"><a href="#val-record" class="anchor"></a><code><span class="keyword">val</span> record : string <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-open_record">open_record</a></span></code></dt><dd><p><code>record n f</code> is an incomplete representation of the record called <code>n</code> of type <code>'a</code> with constructor <code>f</code>. To complete the representation, add fields with <a href="index.html#val-(|+)"><code>(|+)</code></a> and then seal the record with <a href="index.html#val-sealr"><code>sealr</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) field</span></code></dt><dd><p>The type for fields holding values of type <code>'b</code> and belonging to a record of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-field"><a href="#val-field" class="anchor"></a><code><span class="keyword">val</span> field : string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-field">field</a></span></code></dt><dd><p><code>field n t g</code> is the representation of the field <code>n</code> of type <code>t</code> with getter <code>g</code>. <b>Raises.</b> <code>Invalid_argument</code> if <code>n</code> is not valid UTF-8.</p><p>The name <code>n</code> must not be used by any other <code>field</code> in the record.</p><p>For instance:</p><pre><code class="ml">type manuscript = { title : string option }

let manuscript = field &quot;title&quot; (option string) (fun t -&gt; t.title)</code></pre></dd></dl><dl><dt class="spec value" id="val-(|+)"><a href="#val-(|+)" class="anchor"></a><code><span class="keyword">val</span> (|+) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <a href="index.html#type-open_record">open_record</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-field">field</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>)</span> <a href="index.html#type-open_record">open_record</a></span></code></dt><dd><p><code>r |+ f</code> is the open record <code>r</code> augmented with the field <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-sealr"><a href="#val-sealr" class="anchor"></a><code><span class="keyword">val</span> sealr : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span>)</span> <a href="index.html#type-open_record">open_record</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>sealr r</code> seals the open record <code>r</code>. <b>Raises.</b> <code>Invalid_argument</code> if two or more fields share the same name.</p></dd></dl><aside><p>Putting all together:</p><pre><code class="ml">type menu = { restaurant : string; items : (string * int32) list }

let t =
  record &quot;t&quot; (fun restaurant items -&gt; { restaurant; items })
  |+ field &quot;restaurant&quot; string (fun t -&gt; t.restaurant)
  |+ field &quot;items&quot; (list (pair string int32)) (fun t -&gt; t.items)
  |&gt; sealr</code></pre></aside></section><section><header><h2 id="variants"><a href="#variants" class="anchor"></a>Variants</h2></header><dl><dt class="spec type" id="type-open_variant"><a href="#type-open_variant" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b, 'c) open_variant</span></code></dt><dd><p>The type for representing open variants of type <code>'a</code> with pattern matching of type <code>'b</code>. <code>'c</code> represents the remaining constructors to be described using the <a href="index.html#val-(|~)"><code>(|~)</code></a> operator. An open variant initially satisfies <code>c' = 'b</code> and can be <a href="index.html#val-sealv"><span>sealed</span></a> once <code>'c = 'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-variant"><a href="#val-variant" class="anchor"></a><code><span class="keyword">val</span> variant : string <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>)</span> <a href="index.html#type-open_variant">open_variant</a></span></code></dt><dd><p><code>variant n p</code> is an incomplete representation of the variant type called <code>n</code> of type <code>'a</code> using <code>p</code> to deconstruct values. To complete the representation, add cases with <a href="index.html#val-(|~)"><code>(|~)</code></a> and then seal the variant with <a href="index.html#val-sealv"><code>sealv</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-case"><a href="#type-case" class="anchor"></a><code><span class="keyword">type</span> <span>('a, 'b) case</span></code></dt><dd><p>The type for representing variant cases of type <code>'a</code> with patterns of type <code>'b</code>.</p></dd></dl><dl><dt class="spec type" id="type-case_p"><a href="#type-case_p" class="anchor"></a><code><span class="keyword">type</span> <span>'a case_p</span></code></dt><dd><p>The type for representing patterns for a variant of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-case0"><a href="#val-case0" class="anchor"></a><code><span class="keyword">val</span> case0 : string <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a></span>)</span> <a href="index.html#type-case">case</a></span></code></dt><dd><p><code>case0 n v</code> is a representation of a variant constructor <code>v</code> with no arguments and name <code>n</code>. <b>Raises.</b> <code>Invalid_argument</code> if <code>n</code> is not valid UTF-8.</p><p>The name <code>n</code> must not by used by any other <code>case0</code> in the record.</p><p>For instance:</p><pre><code class="ml">type t = Foo

let foo = case0 &quot;Foo&quot; Foo</code></pre></dd></dl><dl><dt class="spec value" id="val-case1"><a href="#val-case1" class="anchor"></a><code><span class="keyword">val</span> case1 : string <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a></span>)</span> <a href="index.html#type-case">case</a></span></code></dt><dd><p><code>case1 n t c</code> is a representation of a variant constructor <code>c</code> with an argument of type <code>t</code> and name <code>n</code>. <b>Raises.</b> <code>Invalid_argument</code> if <code>n</code> is not valid UTF-8.</p><p>The name <code>n</code> must not by used by any other <code>case1</code> in the record.</p><p>For instance:</p><pre><code class="ml">type t = Foo of string

let foo = case1 &quot;Foo&quot; string (fun s -&gt; Foo s)</code></pre></dd></dl><dl><dt class="spec value" id="val-(|~)"><a href="#val-(|~)" class="anchor"></a><code><span class="keyword">val</span> (|~) : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'d</span>)</span> <a href="index.html#type-open_variant">open_variant</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-case">case</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>)</span> <a href="index.html#type-open_variant">open_variant</a></span></code></dt><dd><p><code>v |~ c</code> is the open variant <code>v</code> augmented with the case <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-sealv"><a href="#val-sealv" class="anchor"></a><code><span class="keyword">val</span> sealv : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a></span>)</span> <a href="index.html#type-open_variant">open_variant</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>sealv v</code> seals the open variant <code>v</code>. <b>Raises.</b> <code>Invalid_argument</code> if two or more cases of same arity share the same name.</p></dd></dl><aside><p>Putting all together:</p><pre><code class="ml">type t = Foo | Bar of string

let t =
  variant &quot;t&quot; (fun foo bar -&gt; function Foo -&gt; foo | Bar s -&gt; bar s)
  |~ case0 &quot;Foo&quot; Foo
  |~ case1 &quot;Bar&quot; string (fun x -&gt; Bar x)
  |&gt; sealv</code></pre></aside><dl><dt class="spec value" id="val-enum"><a href="#val-enum" class="anchor"></a><code><span class="keyword">val</span> enum : string <span>&#45;&gt;</span> <span><span>(string * <span class="type-var">'a</span>)</span> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>enum n cs</code> is a representation of the variant type called <code>n</code> with singleton cases <code>cs</code>. e.g.</p><pre><code class="ml">type t = Foo | Bar | Toto

let t = enum &quot;t&quot; [ (&quot;Foo&quot;, Foo); (&quot;Bar&quot;, Bar); (&quot;Toto&quot;, Toto) ]</code></pre><p><b>Raises.</b> <code>Invalid_argument</code> if two or more cases share the same name.</p></dd></dl></section><section><header><h2 id="recursive"><a href="#recursive" class="anchor"></a>Recursive definitions</h2><p><code>Type</code> allows a limited description of recursive records and variants.</p><p><b>TODO</b>: describe the limitations, e.g. only regular recursion and no use of the generics inside the <code>mu*</code> functions and the usual caveats with recursive values (such as infinite loops on most of the generics which don't check sharing).</p></header><dl><dt class="spec value" id="val-mu"><a href="#val-mu" class="anchor"></a><code><span class="keyword">val</span> mu : <span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>mu f</code> is the representation <code>r</code> such that <code>r = mu r</code>.</p><p>For instance:</p><pre><code class="ml">type x = { x : x option }

let x =
  mu (fun x -&gt;
      record &quot;x&quot; (fun x -&gt; { x }) |+ field &quot;x&quot; x (fun x -&gt; x.x) |&gt; sealr)</code></pre></dd></dl><dl><dt class="spec value" id="val-mu2"><a href="#val-mu2" class="anchor"></a><code><span class="keyword">val</span> mu2 : <span>(<span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> * <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>mu2 f</code> is the representations <code>r</code> and <code>s</code> such that <code>r, s = mu2 r s</code>.</p><p>For instance:</p><pre><code class="ml">type r = { foo : int; bar : string list; z : z option }

and z = { x : int; r : r list }

(* Build the representation of [r] knowing [z]'s. *)
let mkr z =
  record &quot;r&quot; (fun foo bar z -&gt; { foo; bar; z })
  |+ field &quot;foo&quot; int (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |+ field &quot;z&quot; (option z) (fun t -&gt; t.z)
  |&gt; sealr

(* And the representation of [z] knowing [r]'s. *)
let mkz r =
  record &quot;z&quot; (fun x r -&gt; { x; r })
  |+ field &quot;x&quot; int (fun t -&gt; t.x)
  |+ field &quot;r&quot; (list r) (fun t -&gt; t.r)
  |&gt; sealr

(* Tie the loop. *)
let r, z = mu2 (fun r z -&gt; (mkr z, mkz y))</code></pre></dd></dl></section><section><header><h2 id="generics"><a href="#generics" class="anchor"></a>Generic Operations</h2><p>Given a value <code>'a t</code>, it is possible to define generic operations on value of type <code>'a</code> such as pretty-printing, parsing and unparsing.</p></header><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal t</code> is the equality function between values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compare t</code> compares values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-short_hash"><a href="#val-short_hash" class="anchor"></a><code><span class="keyword">val</span> short_hash : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>?&#8288;seed:int</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int</code></dt><dd><p><code>hash t x</code> is a short hash of <code>x</code> of type <code>t</code>.</p></dd></dl><dl><dt class="spec type" id="type-pp"><a href="#type-pp" class="anchor"></a><code><span class="keyword">type</span> <span>'a pp</span></code><code> = <span><span class="type-var">'a</span> Fmt.t</span></code></dt><dd><p>The type for pretty-printers.</p></dd></dl><dl><dt class="spec type" id="type-of_string"><a href="#type-of_string" class="anchor"></a><code><span class="keyword">type</span> <span>'a of_string</span></code><code> = string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p>The type for parsers.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-pp">pp</a></span></code></dt><dd><p><code>pp t</code> is the pretty-printer for values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-pp_ty"><a href="#val-pp_ty" class="anchor"></a><code><span class="keyword">val</span> pp_ty : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <a href="index.html#type-pp">pp</a></span></code></dt><dd><p>The pretty printer for generics of type <a href="index.html#type-t"><code>t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string t</code> is <code>Fmt.to_to_string (pp t)</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-of_string">of_string</a></span></code></dt><dd><p><code>of_string t</code> parses values of type <code>t</code>.</p></dd></dl><section><header><h3 id="json-converters"><a href="#json-converters" class="anchor"></a>JSON converters</h3></header><div class="spec module" id="module-Json"><a href="#module-Json" class="anchor"></a><code><span class="keyword">module</span> <a href="Json/index.html">Json</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-encode_json"><a href="#type-encode_json" class="anchor"></a><code><span class="keyword">type</span> <span>'a encode_json</span></code><code> = Jsonm.encoder <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>The type for JSON encoders.</p></dd></dl><dl><dt class="spec type" id="type-decode_json"><a href="#type-decode_json" class="anchor"></a><code><span class="keyword">type</span> <span>'a decode_json</span></code><code> = <a href="Json/index.html#type-decoder">Json.decoder</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p>The type for JSON decoders.</p></dd></dl><dl><dt class="spec value" id="val-pp_json"><a href="#val-pp_json" class="anchor"></a><code><span class="keyword">val</span> pp_json : <span>?&#8288;minify:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Fmt.t</span></code></dt><dd><p>Similar to <code>dump</code> but pretty-prints the JSON representation instead of the OCaml one. See <a href="index.html#type-encode_json"><code>encode_json</code></a> for details about the encoding.</p><p>For instance:</p><pre><code class="ml">type t = { foo : int option; bar : string list }

let t =
  record &quot;r&quot; (fun foo bar -&gt; { foo; bar })
  |+ field &quot;foo&quot; (option int) (fun t -&gt; t.foo)
  |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
  |&gt; sealr

let s = Fmt.strf &quot;%a\n&quot; (pp t) { foo = None; bar = [ &quot;foo&quot; ] }

(* s is &quot;{ foo = None; bar = [\&quot;foo\&quot;]; }&quot; *)

let j = Fmt.strf &quot;%a\n&quot; (pp_json t) { foo = None; bar = [ &quot;foo&quot; ] }

(* j is &quot;{ \&quot;bar\&quot;:[\&quot;foo\&quot;] }&quot; *)</code></pre><p><b>NOTE:</b> this will automatically convert JSON fragments to valid JSON objects by adding an enclosing array if necessary.</p></dd></dl><dl><dt class="spec value" id="val-encode_json"><a href="#val-encode_json" class="anchor"></a><code><span class="keyword">val</span> encode_json : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Jsonm.encoder <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>encode_json t e</code> encodes <code>t</code> into the <a href="http://erratique.ch/software/jsonm">jsonm</a> encoder <code>e</code>. The encoding is a relatively straightforward translation of the OCaml structure into JSON. The main highlights are:</p><ul><li>The unit value <code>()</code> is translated into the empty object <code>{}</code>.</li><li>OCaml ints are translated into JSON floats.</li><li>OCaml strings are translated into JSON strings. You must then ensure that the OCaml strings contains only valid UTF-8 characters.</li><li>OCaml options are translated differently depending on context: record fields with a value of <code>None</code> are removed from the JSON object; record fields with a value of <code>Some x</code> are automatically unboxed into x; and outside of records, <code>None</code> is translated into <code>null</code> and <code>Some x</code> into <code>{&quot;some&quot;: x'}</code> with <code>x'</code> the JSON encoding of <code>x</code>.</li><li>Variant cases built using <a href="index.html#val-case0"><code>case0</code></a> are represented as strings.</li><li>Variant cases built using <a href="index.html#val-case1"><code>case1</code></a> are represented as a record with one field; the field name is the name of the variant.</li></ul><p><b>NOTE:</b> this can be used to encode JSON fragments. It's the responsibility of the caller to ensure that the encoded JSON fragment fits properly into a well-formed JSON object.</p></dd></dl><dl><dt class="spec value" id="val-decode_json"><a href="#val-decode_json" class="anchor"></a><code><span class="keyword">val</span> decode_json : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Jsonm.decoder <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>decode_json t e</code> decodes values of type <code>t</code> from the <a href="http://erratique.ch/software/jsonm">jsonm</a> decoder <code>e</code>.</p></dd></dl><dl><dt class="spec value" id="val-decode_json_lexemes"><a href="#val-decode_json_lexemes" class="anchor"></a><code><span class="keyword">val</span> decode_json_lexemes : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>Jsonm.lexeme list</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>decode_json_lexemes</code> is similar to <a href="index.html#type-decode_json"><code>decode_json</code></a> but uses an already decoded list of JSON lexemes instead of a decoder.</p></dd></dl><dl><dt class="spec value" id="val-to_json_string"><a href="#val-to_json_string" class="anchor"></a><code><span class="keyword">val</span> to_json_string : <span>?&#8288;minify:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_json_string</code> is <a href="index.html#type-encode_json"><code>encode_json</code></a> with a string encoder.</p></dd></dl><dl><dt class="spec value" id="val-of_json_string"><a href="#val-of_json_string" class="anchor"></a><code><span class="keyword">val</span> of_json_string : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>of_json_string</code> is <a href="index.html#type-decode_json"><code>decode_json</code></a> with a string decoder .</p></dd></dl></section><section><header><h3 id="binary-converters"><a href="#binary-converters" class="anchor"></a>Binary Converters</h3></header><dl><dt class="spec type" id="type-bin_seq"><a href="#type-bin_seq" class="anchor"></a><code><span class="keyword">type</span> <span>'a bin_seq</span></code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>(string <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec type" id="type-encode_bin"><a href="#type-encode_bin" class="anchor"></a><code><span class="keyword">type</span> <span>'a encode_bin</span></code><code> = <span>?&#8288;headers:bool</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-bin_seq">bin_seq</a></span></code></dt><dd><p>The type for binary encoders. If <code>headers</code> is not set, do not output extra length headers for buffers.</p></dd></dl><dl><dt class="spec type" id="type-decode_bin"><a href="#type-decode_bin" class="anchor"></a><code><span class="keyword">type</span> <span>'a decode_bin</span></code><code> = <span>?&#8288;headers:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int * <span class="type-var">'a</span></code></dt><dd><p>The type for binary decoders. IF <code>headers</code> is not set, do not read extra length header for buffers and consider the whole buffer instead.</p></dd></dl><dl><dt class="spec type" id="type-size_of"><a href="#type-size_of" class="anchor"></a><code><span class="keyword">type</span> <span>'a size_of</span></code><code> = <span>?&#8288;headers:bool</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p>The type for size function related to binary encoder/decoders.</p></dd></dl><dl><dt class="spec value" id="val-pre_hash"><a href="#val-pre_hash" class="anchor"></a><code><span class="keyword">val</span> pre_hash : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-bin_seq">bin_seq</a></span></code></dt><dd><p><code>pre_hash t x</code> is the string representation of <code>x</code>, of type <code>t</code>, which will be used to compute the digest of the value. By default it's <code>to_bin_string t x</code> but it can be overriden by <a href="index.html#val-v"><code>v</code></a>, <a href="index.html#val-like"><code>like</code></a> and <a href="index.html#val-map"><code>map</code></a> operators.</p></dd></dl><dl><dt class="spec value" id="val-encode_bin"><a href="#val-encode_bin" class="anchor"></a><code><span class="keyword">val</span> encode_bin : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-encode_bin">encode_bin</a></span></code></dt><dd><p><code>encode_bin t</code> is the binary encoder for values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-decode_bin"><a href="#val-decode_bin" class="anchor"></a><code><span class="keyword">val</span> decode_bin : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-decode_bin">decode_bin</a></span></code></dt><dd><p><code>decode_bin t</code> is the binary decoder for values of type <code>t</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_bin_string"><a href="#val-to_bin_string" class="anchor"></a><code><span class="keyword">val</span> to_bin_string : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_bin_string t x</code> use <a href="index.html#type-encode_bin"><code>encode_bin</code></a> to convert <code>x</code>, of type <code>t</code>, to a string.</p><p><b>NOTE:</b> When <code>t</code> is <a href="index.html#val-string"><code>Type.string</code></a> or <a href="index.html#val-bytes"><code>Type.bytes</code></a>, the original buffer <code>x</code> is not prefixed by its size as <a href="index.html#type-encode_bin"><code>encode_bin</code></a> would do. If <code>t</code> is <a href="index.html#val-string"><code>Type.string</code></a>, the result is <code>x</code> (without copy).</p></dd></dl><dl><dt class="spec value" id="val-of_bin_string"><a href="#val-of_bin_string" class="anchor"></a><code><span class="keyword">val</span> of_bin_string : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>of_bin_string t s</code> is <code>v</code> such that <code>s = to_bin_string t v</code>.</p><p><b>NOTE:</b> When <code>t</code> is <a href="index.html#val-string"><code>Type.string</code></a>, the result is <code>s</code> (without copy).</p></dd></dl><dl><dt class="spec value" id="val-size_of"><a href="#val-size_of" class="anchor"></a><code><span class="keyword">val</span> size_of : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-size_of">size_of</a></span></code></dt><dd><p><code>size_of t x</code> is either the size of <code>encode_bin t x</code> or the binary encoding of <code>x</code>, if the backend is not able to pre-compute serialisation lengths.</p></dd></dl></section></section><section><header><h2 id="customs-converters"><a href="#customs-converters" class="anchor"></a>Customs converters</h2></header><dl><dt class="spec value" id="val-v"><a href="#val-v" class="anchor"></a><code><span class="keyword">val</span> v : <span>cli:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-pp">pp</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-of_string">of_string</a></span>)</span></span> <span>&#45;&gt;</span> <span>json:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-encode_json">encode_json</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-decode_json">decode_json</a></span>)</span></span> <span>&#45;&gt;</span> <span>bin:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-size_of">size_of</a></span>)</span></span> <span>&#45;&gt;</span> <span>equal:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>short_hash:<span>(<span>?&#8288;seed:int</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>pre_hash:<span><span class="type-var">'a</span> <a href="index.html#type-bin_seq">bin_seq</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-like"><a href="#val-like" class="anchor"></a><code><span class="keyword">val</span> like : <span>?&#8288;cli:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-pp">pp</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-of_string">of_string</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;json:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-encode_json">encode_json</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-decode_json">decode_json</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;bin:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-size_of">size_of</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;equal:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;short_hash:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pre_hash:<span><span class="type-var">'a</span> <a href="index.html#type-bin_seq">bin_seq</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>?&#8288;cli:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-pp">pp</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-of_string">of_string</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;json:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-encode_json">encode_json</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-decode_json">decode_json</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;bin:<span>(<span><span class="type-var">'a</span> <a href="index.html#type-encode_bin">encode_bin</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-decode_bin">decode_bin</a></span> * <span><span class="type-var">'a</span> <a href="index.html#type-size_of">size_of</a></span>)</span></span> <span>&#45;&gt;</span> <span>?&#8288;equal:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span>?&#8288;compare:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;short_hash:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></span> <span>&#45;&gt;</span> <span>?&#8288;pre_hash:<span><span class="type-var">'a</span> <a href="index.html#type-bin_seq">bin_seq</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt></dl><dl><dt class="spec type" id="type-ty"><a href="#type-ty" class="anchor"></a><code><span class="keyword">type</span> <span>'a ty</span></code><code> = <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt></dl><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>