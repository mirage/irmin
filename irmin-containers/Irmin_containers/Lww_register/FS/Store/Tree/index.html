<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tree (irmin-containers.Irmin_containers.Lww_register.FS.Store.Tree)</title><link rel="stylesheet" href="../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../../index.html">irmin-containers</a> &#x00BB; <a href="../../../../index.html">Irmin_containers</a> &#x00BB; <a href="../../../index.html">Lww_register</a> &#x00BB; <a href="../../index.html">FS</a> &#x00BB; <a href="../index.html">Store</a> &#x00BB; Tree</nav><header class="odoc-preamble"><h1>Module <code><span>Store.Tree</span></code></h1><p>Managing store's trees.</p></header><nav class="odoc-toc"><ul><li><a href="#constructors">Constructors</a></li><li><a href="#diffs">Diffs</a></li><li><a href="#manipulating-contents">Manipulating Contents</a></li><li><a href="#manipulating-subtrees">Manipulating Subtrees</a></li><li><a href="#folds">Folds</a></li><li><a href="#stats">Stats</a></li><li><a href="#concrete-trees">Concrete Trees</a></li><li><a href="#proofs">Proofs</a></li><li><a href="#caches">Caches</a></li><li><a href="#performance-counters">Performance counters</a></li><li><a href="#import/export">Import/Export</a></li><li><a href="#proofs_2">Proofs</a></li></ul></nav><div class="odoc-content"><div class="odoc-include"><div class="odoc-include"><p><code>Tree</code> provides immutable, in-memory partial mirror of the store, with lazy reads and delayed writes.</p><p>Trees are like staging area in Git: they are immutable temporary non-persistent areas (they disappear if the host crash), held in memory for efficiency, where reads are done lazily and writes are done only when needed on commit: if you modify a key twice, only the last change will be written to the store when you commit.</p><h2 id="constructors"><a href="#constructors" class="anchor"></a>Constructors</h2><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p><code>empty ()</code> is the empty tree. The empty tree does not have associated backend configuration values, as they can perform in-memory operation, independently of any given backend.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_contents" class="anchored"><a href="#val-of_contents" class="anchor"></a><code><span><span class="keyword">val</span> of_contents : <span>?metadata:<a href="../index.html#type-metadata">metadata</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-contents">contents</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p><code>of_contents c</code> is the subtree built from the contents <code>c</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_node" class="anchored"><a href="#val-of_node" class="anchor"></a><code><span><span class="keyword">val</span> of_node : <span><a href="../index.html#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p><code>of_node n</code> is the subtree built from the node <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-elt" class="anchored"><a href="#type-elt" class="anchor"></a><code><span><span class="keyword">type</span> elt</span><span> = </span><span>[ </span></code><table><tr id="type-elt.Node" class="anchored"><td class="def constructor"><a href="#type-elt.Node" class="anchor"></a><code><span>| </span></code><code><span>`Node <span class="keyword">of</span> <a href="../index.html#type-node">node</a></span></code></td></tr><tr id="type-elt.Contents" class="anchored"><td class="def constructor"><a href="#type-elt.Contents" class="anchor"></a><code><span>| </span></code><code><span>`Contents <span class="keyword">of</span> <a href="../index.html#type-contents">contents</a> * <a href="../index.html#type-metadata">metadata</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for tree elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-v" class="anchored"><a href="#val-v" class="anchor"></a><code><span><span class="keyword">val</span> v : <span><a href="#type-elt">elt</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p>General-purpose constructor for trees.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kinded_hash_t" class="anchored"><a href="#val-kinded_hash_t" class="anchor"></a><code><span><span class="keyword">val</span> kinded_hash_t : <span><span>[ <span>`Contents of <a href="../index.html#type-hash">hash</a> * <a href="../index.html#type-metadata">metadata</a></span> <span><span>| `Node</span> of <a href="../index.html#type-hash">hash</a></span> ]</span> <a href="../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pruned" class="anchored"><a href="#val-pruned" class="anchor"></a><code><span><span class="keyword">val</span> pruned : <span><span>[ <span>`Contents of <a href="../index.html#type-hash">hash</a> * <a href="../index.html#type-metadata">metadata</a></span> <span><span>| `Node</span> of <a href="../index.html#type-hash">hash</a></span> ]</span> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p><code>pruned h</code> is a purely in-memory tree with the hash <code>h</code>. Such trees can be used as children of other in-memory tree nodes, for instance in order to compute the hash of the parent, but they cannot be dereferenced.</p><p>Any operation that would require loading the contents of a pruned node (e.g. calling <a href="#val-find"><code>find</code></a> on one of its children) will instead raise a <a href="#exception-Pruned_hash"><code>Pruned_hash</code></a> exception. Attempting to export a tree containing pruned sub-trees to a repository will fail similarly.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kind" class="anchored"><a href="#val-kind" class="anchor"></a><code><span><span class="keyword">val</span> kind : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>[ `Contents <span>| `Node</span> ]</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>kind t k</code> is the type of <code>s</code> in <code>t</code>. It could either be a tree node or some file contents. It is <code>None</code> if <code>k</code> is not present in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_empty" class="anchored"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty t</code> is true iff <code>t</code> is <a href="#val-empty"><code>empty</code></a> (i.e. a tree node with no children). Trees with <a href="#val-kind"><code>kind</code></a> = <code>`Contents</code> are never considered empty.</p></div></div><h2 id="diffs"><a href="#diffs" class="anchor"></a>Diffs</h2><div class="odoc-spec"><div class="spec value" id="val-diff" class="anchored"><a href="#val-diff" class="anchor"></a><code><span><span class="keyword">val</span> diff : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../index.html#type-key">key</a> * <span><span>(<a href="../index.html#type-contents">contents</a> * <a href="../index.html#type-metadata">metadata</a>)</span> <a href="../../../../../../irmin/Irmin/Diff/index.html#type-t">Irmin.Diff.t</a></span>)</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>diff x y</code> is the difference of contents between <code>x</code> and <code>y</code>.</p></div></div><h2 id="manipulating-contents"><a href="#manipulating-contents" class="anchor"></a>Manipulating Contents</h2><div class="odoc-spec"><div class="spec type" id="type-error" class="anchored"><a href="#type-error" class="anchor"></a><code><span><span class="keyword">type</span> error</span><span> = </span><span>[ </span></code><table><tr id="type-error.Dangling_hash" class="anchored"><td class="def constructor"><a href="#type-error.Dangling_hash" class="anchor"></a><code><span>| </span></code><code><span>`Dangling_hash <span class="keyword">of</span> <a href="../index.html#type-hash">hash</a></span></code></td></tr><tr id="type-error.Pruned_hash" class="anchored"><td class="def constructor"><a href="#type-error.Pruned_hash" class="anchor"></a><code><span>| </span></code><code><span>`Pruned_hash <span class="keyword">of</span> <a href="../index.html#type-hash">hash</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for errors.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-or_error" class="anchored"><a href="#type-or_error" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a or_error</span></span><span> = <span><span>(<span class="type-var">'a</span>, <a href="#type-error">error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Operations on lazy nodes can fail if the underlying store does not contain the expected hash.</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Pruned_hash" class="anchored"><a href="#exception-Pruned_hash" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Pruned_hash</span> <span class="keyword">of</span> </span><span>{</span></code><table><tr id="module-Tree.context" class="anchored"><td class="def record field"><a href="#module-Tree.context" class="anchor"></a><code><span>context : string;</span></code></td></tr><tr id="module-Tree.hash" class="anchored"><td class="def record field"><a href="#module-Tree.hash" class="anchor"></a><code><span>hash : <a href="../index.html#type-hash">hash</a>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The exception raised by functions that attempt to load <a href="#val-pruned"><code>pruned</code></a> tree nodes.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Contents" class="anchored"><a href="#module-Contents" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Contents/index.html">Contents</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operations on lazy tree contents.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mem" class="anchored"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem t k</code> is true iff <code>k</code> is associated to some contents in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_all" class="anchored"><a href="#val-find_all" class="anchor"></a><code><span><span class="keyword">val</span> find_all : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../index.html#type-contents">contents</a> * <a href="../index.html#type-metadata">metadata</a>)</span> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_all t k</code> is <code>Some (b, m)</code> if <code>k</code> is associated to the contents <code>b</code> and metadata <code>m</code> in <code>t</code> and <code>None</code> if <code>k</code> is not present in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-length" class="anchored"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span>?cache:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>length t key</code> is the number of files and sub-nodes stored under <code>k</code> in <code>t</code>.</p><p>It is equivalent to <code>List.length (list t k)</code> but backends might optimise this call: for instance it's a constant time operation in <code>irmin-pack</code>.</p><p><code>cache</code> defaults to <code>true</code>, see <code>caching</code> for an explanation of the parameter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find" class="anchored"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../index.html#type-contents">contents</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find</code> is similar to <a href="#val-find_all"><code>find_all</code></a> but it discards metadata.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_all" class="anchored"><a href="#val-get_all" class="anchor"></a><code><span><span class="keyword">val</span> get_all : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-contents">contents</a> * <a href="../index.html#type-metadata">metadata</a>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-find_all"><code>find_all</code></a> but raise <code>Invalid_arg</code> if <code>k</code> is not present in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-list" class="anchored"><a href="#val-list" class="anchor"></a><code><span><span class="keyword">val</span> list : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span>?offset:int <span class="arrow">&#45;&gt;</span></span> <span>?length:int <span class="arrow">&#45;&gt;</span></span> <span>?cache:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../index.html#type-step">step</a> * <a href="../index.html#type-tree">tree</a>)</span> list</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>list t key</code> is the list of files and sub-nodes stored under <code>k</code> in <code>t</code>. The result order is not specified but is stable.</p><p><code>offset</code> and <code>length</code> are used for pagination.</p><p><code>cache</code> defaults to <code>true</code>, see <code>caching</code> for an explanation of the parameter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-contents">contents</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-get_all"><code>get_all</code></a> but ignore the metadata.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>?metadata:<a href="../index.html#type-metadata">metadata</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-contents">contents</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>add t k c</code> is the tree where the key <code>k</code> is bound to the contents <code>c</code> but is similar to <code>t</code> for other bindings.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-update" class="anchored"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>?metadata:<a href="../index.html#type-metadata">metadata</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><a href="../index.html#type-contents">contents</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-contents">contents</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update t k f</code> is the tree <code>t'</code> that is the same as <code>t</code> for all keys except <code>k</code>, and whose binding for <code>k</code> is determined by <code>f (find t k)</code>.</p><p>If <code>k</code> refers to an internal node of <code>t</code>, <code>f</code> is called with <code>None</code> to determine the value with which to replace it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-remove" class="anchored"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>remove t k</code> is the tree where <code>k</code> bindings has been removed but is similar to <code>t</code> for other bindings.</p></div></div><h2 id="manipulating-subtrees"><a href="#manipulating-subtrees" class="anchor"></a>Manipulating Subtrees</h2><div class="odoc-spec"><div class="spec value" id="val-mem_tree" class="anchored"><a href="#val-mem_tree" class="anchor"></a><code><span><span class="keyword">val</span> mem_tree : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>mem_tree t k</code> is false iff <code>find_tree k = None</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_tree" class="anchored"><a href="#val-find_tree" class="anchor"></a><code><span><span class="keyword">val</span> find_tree : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../index.html#type-tree">tree</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>find_tree t k</code> is <code>Some v</code> if <code>k</code> is associated to <code>v</code> in <code>t</code>. It is <code>None</code> if <code>k</code> is not present in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_tree" class="anchored"><a href="#val-get_tree" class="anchor"></a><code><span><span class="keyword">val</span> get_tree : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>get_tree t k</code> is <code>v</code> if <code>k</code> is associated to <code>v</code> in <code>t</code>. Raise <code>Invalid_arg</code> if <code>k</code> is not present in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_tree" class="anchored"><a href="#val-add_tree" class="anchor"></a><code><span><span class="keyword">val</span> add_tree : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>add_tree t k v</code> is the tree where the key <code>k</code> is bound to the non-empty tree <code>v</code> but is similar to <code>t</code> for other bindings.</p><p>If <code>v</code> is empty, this is equivalent to <code>remove t k</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-update_tree" class="anchored"><a href="#val-update_tree" class="anchor"></a><code><span><span class="keyword">val</span> update_tree : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><a href="../index.html#type-tree">tree</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>update_tree t k f</code> is the tree <code>t'</code> that is the same as <code>t</code> for all subtrees except under <code>k</code>, and whose subtree at <code>k</code> is determined by <code>f (find_tree t k)</code>.</p><p><code>f</code> returning either <code>None</code> or <code>Some empty</code> causes the subtree at <code>k</code> to be unbound (i.e. it is equivalent to <code>remove t k</code>).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge" class="anchored"><a href="#val-merge" class="anchor"></a><code><span><span class="keyword">val</span> merge : <span><a href="../index.html#type-tree">tree</a> <a href="../../../../../../irmin/Irmin/Merge/index.html#type-t">Irmin.Merge.t</a></span></span></code></div><div class="spec-doc"><p><code>merge</code> is the 3-way merge function for trees.</p></div></div><h2 id="folds"><a href="#folds" class="anchor"></a>Folds</h2><div class="odoc-spec"><div class="spec value" id="val-destruct" class="anchored"><a href="#val-destruct" class="anchor"></a><code><span><span class="keyword">val</span> destruct : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span>[ <span>`Node of <a href="../index.html#type-node">node</a></span> <span><span>| `Contents</span> of <a href="Contents/index.html#type-t">Contents.t</a> * <a href="../index.html#type-metadata">metadata</a></span> ]</span></span></code></div><div class="spec-doc"><p>General-purpose destructor for trees.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-marks" class="anchored"><a href="#type-marks" class="anchor"></a><code><span><span class="keyword">type</span> marks</span></code></div><div class="spec-doc"><p>The type for fold marks.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty_marks" class="anchored"><a href="#val-empty_marks" class="anchor"></a><code><span><span class="keyword">val</span> empty_marks : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-marks">marks</a></span></code></div><div class="spec-doc"><p><code>empty_marks ()</code> is an empty collection of marks.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-force" class="anchored"><a href="#type-force" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a force</span></span><span> = </span><span>[ </span></code><table><tr id="type-force.True" class="anchored"><td class="def constructor"><a href="#type-force.True" class="anchor"></a><code><span>| </span></code><code><span>`True</span></code></td></tr><tr id="type-force.False" class="anchored"><td class="def constructor"><a href="#type-force.False" class="anchor"></a><code><span>| </span></code><code><span>`False <span class="keyword">of</span> <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for <a href="#val-fold"><code>fold</code></a>'s <code>force</code> parameter. <code>`True</code> forces the fold to read the objects of the lazy nodes and contents. <code>`False f</code> is applying <code>f</code> on every lazy node and content value instead.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-uniq" class="anchored"><a href="#type-uniq" class="anchor"></a><code><span><span class="keyword">type</span> uniq</span><span> = </span><span>[ </span></code><table><tr id="type-uniq.False" class="anchored"><td class="def constructor"><a href="#type-uniq.False" class="anchor"></a><code><span>| </span></code><code><span>`False</span></code></td></tr><tr id="type-uniq.True" class="anchored"><td class="def constructor"><a href="#type-uniq.True" class="anchor"></a><code><span>| </span></code><code><span>`True</span></code></td></tr><tr id="type-uniq.Marks" class="anchored"><td class="def constructor"><a href="#type-uniq.Marks" class="anchor"></a><code><span>| </span></code><code><span>`Marks <span class="keyword">of</span> <a href="#type-marks">marks</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for <a href="#val-fold"><code>fold</code></a>'s <code>uniq</code> parameters. <code>`False</code> folds over all the nodes. <code>`True</code> does not recurse on nodes already seen. <code>`Marks m</code> uses the collection of marks <code>m</code> to store the cache of keys: the fold will modify <code>m</code>. This can be used for incremental folds.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-node_fn" class="anchored"><a href="#type-node_fn" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a node_fn</span></span><span> = <span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../index.html#type-step">step</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p>The type for <a href="#val-fold"><code>fold</code></a>'s <code>pre</code> and <code>post</code> parameters.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-depth" class="anchored"><a href="#type-depth" class="anchor"></a><code><span><span class="keyword">type</span> depth</span><span> = </span><span>[ </span></code><table><tr id="type-depth.Eq" class="anchored"><td class="def constructor"><a href="#type-depth.Eq" class="anchor"></a><code><span>| </span></code><code><span>`Eq <span class="keyword">of</span> int</span></code></td></tr><tr id="type-depth.Le" class="anchored"><td class="def constructor"><a href="#type-depth.Le" class="anchor"></a><code><span>| </span></code><code><span>`Le <span class="keyword">of</span> int</span></code></td></tr><tr id="type-depth.Lt" class="anchored"><td class="def constructor"><a href="#type-depth.Lt" class="anchor"></a><code><span>| </span></code><code><span>`Lt <span class="keyword">of</span> int</span></code></td></tr><tr id="type-depth.Ge" class="anchored"><td class="def constructor"><a href="#type-depth.Ge" class="anchor"></a><code><span>| </span></code><code><span>`Ge <span class="keyword">of</span> int</span></code></td></tr><tr id="type-depth.Gt" class="anchored"><td class="def constructor"><a href="#type-depth.Gt" class="anchor"></a><code><span>| </span></code><code><span>`Gt <span class="keyword">of</span> int</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for fold depths.</p><ul><li><code>Eq d</code> folds over nodes and contents of depth exactly <code>d</code>.</li><li><code>Lt d</code> folds over nodes and contents of depth strictly less than <code>d</code>.</li><li><code>Gt d</code> folds over nodes and contents of depth strictly more than <code>d</code>.</li></ul><p><code>Le d</code> is <code>Eq d</code> and <code>Lt d</code>. <code>Ge d</code> is <code>Eq d</code> and <code>Gt d</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-depth_t" class="anchored"><a href="#val-depth_t" class="anchor"></a><code><span><span class="keyword">val</span> depth_t : <span><a href="#type-depth">depth</a> <a href="../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-fold" class="anchored"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span>?order:<span>[ `Sorted <span>| `Undefined</span> <span><span>| `Random</span> of <span class="xref-unresolved">Stdlib</span>.Random.State.t</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
<span>?force:<span><span class="type-var">'a</span> <a href="#type-force">force</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?cache:bool <span class="arrow">&#45;&gt;</span></span> <span>?uniq:<a href="#type-uniq">uniq</a> <span class="arrow">&#45;&gt;</span></span> <span>?pre:<span><span class="type-var">'a</span> <a href="#type-node_fn">node_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?post:<span><span class="type-var">'a</span> <a href="#type-node_fn">node_fn</a></span> <span class="arrow">&#45;&gt;</span></span> <span>?depth:<a href="#type-depth">depth</a> <span class="arrow">&#45;&gt;</span></span>
<span>?contents:<span>(<span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-contents">contents</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?node:<span>(<span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-node">node</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>?tree:<span>(<span><a href="../index.html#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span>
<span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>fold f t acc</code> folds <code>f</code> over <code>t</code>'s leafs.</p><p>For every node <code>n</code>, ui <code>n</code> is a leaf node, call <code>f path n</code>. Otherwise:</p><ul><li>Call <code>pre path n</code>. By default <code>pre</code> is the identity;</li><li>Recursively call <code>fold</code> on each children.</li><li>Call <code>post path n</code>; By default <code>post</code> is the identity.</li></ul><p>See <a href="#type-force"><code>force</code></a> for details about the <code>force</code> parameters. By default it is <code>`True</code>.</p><p>See <a href="#type-uniq"><code>uniq</code></a> for details about the <code>uniq</code> parameters. By default it is <code>`False</code>.</p><p>The fold depth is controlled by the <code>depth</code> parameter.</p><p><code>cache</code> defaults to <code>false</code>, see <code>caching</code> for an explanation of the parameter.</p><p>If <code>order</code> is <code>`Sorted</code> (the default), the elements are traversed in lexicographic order of their keys. If <code>`Random state</code>, they are traversed in a random order. For large nodes, these two modes are memory-consuming, use <code>`Undefined</code> for a more memory efficient <code>fold</code>.</p></div></div><h2 id="stats"><a href="#stats" class="anchor"></a>Stats</h2><div class="odoc-spec"><div class="spec type" id="type-stats" class="anchored"><a href="#type-stats" class="anchor"></a><code><span><span class="keyword">type</span> stats</span><span> = </span><span>{</span></code><table><tr id="type-stats.nodes" class="anchored"><td class="def record field"><a href="#type-stats.nodes" class="anchor"></a><code><span>nodes : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of node.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stats.leafs" class="anchored"><td class="def record field"><a href="#type-stats.leafs" class="anchor"></a><code><span>leafs : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of leafs.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stats.skips" class="anchored"><td class="def record field"><a href="#type-stats.skips" class="anchor"></a><code><span>skips : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Number of lazy nodes.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stats.depth" class="anchored"><td class="def record field"><a href="#type-stats.depth" class="anchor"></a><code><span>depth : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Maximal depth.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stats.width" class="anchored"><td class="def record field"><a href="#type-stats.width" class="anchor"></a><code><span>width : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Maximal width.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type for tree stats.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stats_t" class="anchored"><a href="#val-stats_t" class="anchor"></a><code><span><span class="keyword">val</span> stats_t : <span><a href="#type-stats">stats</a> <a href="../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-stats" class="anchored"><a href="#val-stats" class="anchor"></a><code><span><span class="keyword">val</span> stats : <span>?force:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stats">stats</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>stats ~force t</code> are <code>t</code>'s statistics. If <code>force</code> is true, this will force the reading of lazy nodes. By default it is <code>false</code>.</p></div></div><h2 id="concrete-trees"><a href="#concrete-trees" class="anchor"></a>Concrete Trees</h2><div class="odoc-spec"><div class="spec type" id="type-concrete" class="anchored"><a href="#type-concrete" class="anchor"></a><code><span><span class="keyword">type</span> concrete</span><span> = </span><span>[ </span></code><table><tr id="type-concrete.Tree" class="anchored"><td class="def constructor"><a href="#type-concrete.Tree" class="anchor"></a><code><span>| </span></code><code><span>`Tree <span class="keyword">of</span> <span><span>(<a href="../index.html#type-step">step</a> * <a href="#type-concrete">concrete</a>)</span> list</span></span></code></td></tr><tr id="type-concrete.Contents" class="anchored"><td class="def constructor"><a href="#type-concrete.Contents" class="anchor"></a><code><span>| </span></code><code><span>`Contents <span class="keyword">of</span> <a href="../index.html#type-contents">contents</a> * <a href="../index.html#type-metadata">metadata</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>The type for concrete trees.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-concrete_t" class="anchored"><a href="#val-concrete_t" class="anchor"></a><code><span><span class="keyword">val</span> concrete_t : <span><a href="#type-concrete">concrete</a> <a href="../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-concrete_t" class="anchored"><a href="#val-concrete_t" class="anchor"></a><code><span><span class="keyword">val</span> concrete_t : <span><a href="#type-concrete">concrete</a> <a href="../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div><div class="spec-doc"><p>The value-type for <a href="#type-concrete"><code>concrete</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_concrete" class="anchored"><a href="#val-of_concrete" class="anchor"></a><code><span><span class="keyword">val</span> of_concrete : <span><a href="#type-concrete">concrete</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p><code>of_concrete c</code> is the subtree equivalent of the concrete tree <code>c</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>c</code> contains duplicate bindings for a given path.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-to_concrete" class="anchored"><a href="#val-to_concrete" class="anchor"></a><code><span><span class="keyword">val</span> to_concrete : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-concrete">concrete</a> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>to_concrete t</code> is the concrete tree equivalent of the subtree <code>t</code>.</p></div></div><h2 id="proofs"><a href="#proofs" class="anchor"></a>Proofs</h2><div class="odoc-spec"><div class="spec module" id="module-Proof" class="anchored"><a href="#module-Proof" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Proof/index.html">Proof</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="caches"><a href="#caches" class="anchor"></a>Caches</h2><div class="odoc-spec"><div class="spec value" id="val-clear" class="anchored"><a href="#val-clear" class="anchor"></a><code><span><span class="keyword">val</span> clear : <span>?depth:int <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>clear ?depth t</code> clears all caches in the tree <code>t</code> for subtrees with a depth higher than <code>depth</code>. If <code>depth</code> is not set, all of the subtrees are cleared.</p><p>A call to <code>clear</code> doesn't discard the subtrees of <code>t</code>, only their cache are discarded. Even the lazily loaded and unmodified subtrees remain.</p></div></div><h2 id="performance-counters"><a href="#performance-counters" class="anchor"></a>Performance counters</h2><div class="odoc-spec"><div class="spec type" id="type-counters" class="anchored"><a href="#type-counters" class="anchor"></a><code><span><span class="keyword">type</span> counters</span><span> = </span><span>{</span></code><table><tr id="type-counters.contents_hash" class="anchored"><td class="def record field"><a href="#type-counters.contents_hash" class="anchor"></a><code><span><span class="keyword">mutable</span> contents_hash : int;</span></code></td></tr><tr id="type-counters.contents_find" class="anchored"><td class="def record field"><a href="#type-counters.contents_find" class="anchor"></a><code><span><span class="keyword">mutable</span> contents_find : int;</span></code></td></tr><tr id="type-counters.contents_add" class="anchored"><td class="def record field"><a href="#type-counters.contents_add" class="anchor"></a><code><span><span class="keyword">mutable</span> contents_add : int;</span></code></td></tr><tr id="type-counters.node_hash" class="anchored"><td class="def record field"><a href="#type-counters.node_hash" class="anchor"></a><code><span><span class="keyword">mutable</span> node_hash : int;</span></code></td></tr><tr id="type-counters.node_mem" class="anchored"><td class="def record field"><a href="#type-counters.node_mem" class="anchor"></a><code><span><span class="keyword">mutable</span> node_mem : int;</span></code></td></tr><tr id="type-counters.node_add" class="anchored"><td class="def record field"><a href="#type-counters.node_add" class="anchor"></a><code><span><span class="keyword">mutable</span> node_add : int;</span></code></td></tr><tr id="type-counters.node_find" class="anchored"><td class="def record field"><a href="#type-counters.node_find" class="anchor"></a><code><span><span class="keyword">mutable</span> node_find : int;</span></code></td></tr><tr id="type-counters.node_val_v" class="anchored"><td class="def record field"><a href="#type-counters.node_val_v" class="anchor"></a><code><span><span class="keyword">mutable</span> node_val_v : int;</span></code></td></tr><tr id="type-counters.node_val_find" class="anchored"><td class="def record field"><a href="#type-counters.node_val_find" class="anchor"></a><code><span><span class="keyword">mutable</span> node_val_find : int;</span></code></td></tr><tr id="type-counters.node_val_list" class="anchored"><td class="def record field"><a href="#type-counters.node_val_list" class="anchor"></a><code><span><span class="keyword">mutable</span> node_val_list : int;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-counters" class="anchored"><a href="#val-counters" class="anchor"></a><code><span><span class="keyword">val</span> counters : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-counters">counters</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dump_counters" class="anchored"><a href="#val-dump_counters" class="anchor"></a><code><span><span class="keyword">val</span> dump_counters : <span>unit <span class="xref-unresolved">Fmt</span>.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-reset_counters" class="anchored"><a href="#val-reset_counters" class="anchor"></a><code><span><span class="keyword">val</span> reset_counters : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-inspect" class="anchored"><a href="#val-inspect" class="anchor"></a><code><span><span class="keyword">val</span> inspect : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `Contents <span><span>| `Node</span> of <span>[ `Map <span>| `Hash</span> <span>| `Value</span> <span>| `Pruned</span> ]</span></span> ]</span></span></code></div></div><p>/</p><p>Internals Useful for testing purposes only.</p><div class="odoc-spec"><div class="spec module" id="module-Env" class="anchored"><a href="#module-Env" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Env/index.html">Env</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-get_env" class="anchored"><a href="#val-get_env" class="anchor"></a><code><span><span class="keyword">val</span> get_env : <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <a href="Env/index.html#type-t">Env.t</a></span></code></div></div></div></div><h2 id="import/export"><a href="#import/export" class="anchor"></a>Import/Export</h2><div class="odoc-spec"><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span>?cache:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-hash">hash</a></span></code></div><div class="spec-doc"><p><code>hash c</code> is <code>c</code>'s hash.</p></div></div><div class="odoc-spec"><div class="spec type subst" id="type-kinded_hash" class="anchored"><a href="#type-kinded_hash" class="anchor"></a><code><span><span class="keyword">type</span> kinded_hash</span><span> := </span><span>[ </span></code><table><tr id="type-kinded_hash.Contents" class="anchored"><td class="def constructor"><a href="#type-kinded_hash.Contents" class="anchor"></a><code><span>| </span></code><code><span>`Contents <span class="keyword">of</span> <a href="../index.html#type-hash">hash</a> * <a href="../index.html#type-metadata">metadata</a></span></code></td></tr><tr id="type-kinded_hash.Node" class="anchored"><td class="def constructor"><a href="#type-kinded_hash.Node" class="anchor"></a><code><span>| </span></code><code><span>`Node <span class="keyword">of</span> <a href="../index.html#type-hash">hash</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Hashes in the Irmin store are tagged with the type of the value they reference (either <a href="../index.html#type-contents"><code>contents</code></a> or <a href="../index.html#type-node"><code>node</code></a>). In the <code>contents</code> case, the hash is paired with corresponding <a href="../index.html#type-metadata"><code>metadata</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kinded_hash" class="anchored"><a href="#val-kinded_hash" class="anchor"></a><code><span><span class="keyword">val</span> kinded_hash : <span>?cache:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-kinded_hash">kinded_hash</a></span></code></div><div class="spec-doc"><p><code>kinded_hash t</code> is <code>c</code>'s kinded hash.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_hash" class="anchored"><a href="#val-of_hash" class="anchor"></a><code><span><span class="keyword">val</span> of_hash : <span><a href="../Repo/index.html#type-t">Repo.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-kinded_hash">kinded_hash</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../index.html#type-tree">tree</a> option</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>of_hash r h</code> is the the tree object in <code>r</code> having <code>h</code> as hash, or <code>None</code> is no such tree object exists.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shallow" class="anchored"><a href="#val-shallow" class="anchor"></a><code><span><span class="keyword">val</span> shallow : <span><a href="../Repo/index.html#type-t">Repo.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-kinded_hash">kinded_hash</a> <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p><code>shallow r h</code> is the shallow tree object with the hash <code>h</code>. No check is performed to verify if <code>h</code> actually exists in <code>r</code>.</p></div></div><h2 id="proofs_2"><a href="#proofs_2" class="anchor"></a>Proofs</h2><div class="odoc-spec"><div class="spec type subst" id="type-producer" class="anchored"><a href="#type-producer" class="anchor"></a><code><span><span class="keyword">type</span> <span>('proof, 'result) producer</span></span><span> := <span><a href="../index.html#type-repo">repo</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-kinded_hash">kinded_hash</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-tree">tree</a> * <span class="type-var">'result</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'proof</span> * <span class="type-var">'result</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>produce r h f</code> runs <code>f</code> on top of a real store <code>r</code>, producing a proof and a reulst using the initial root hash <code>h</code>.</p><p>The trees produced during <code>f</code>'s computation will carry the full history of reads. This history will be reset when <code>f</code> is complete so subtrees escaping the scope of <code>f</code> will not cause memory leaks.</p><p>It is possible to call <code>produce_proof</code> recursively. In that case, each input trees will have their own history of reads and will contain only the reads needed to unshallow that corresponding trees. Proof trees proof should then interact as if they were all unshallowed (note: in the case of nested proofs, it's unclear what <code>verify_proof</code> should do...).</p></div></div><div class="odoc-spec"><div class="spec type subst" id="type-verifier" class="anchored"><a href="#type-verifier" class="anchor"></a><code><span><span class="keyword">type</span> <span>('proof, 'result) verifier</span></span><span> := <span><span class="type-var">'proof</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../index.html#type-tree">tree</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../index.html#type-tree">tree</a> * <span class="type-var">'result</span>)</span> <span class="xref-unresolved">Lwt</span>.t</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../index.html#type-tree">tree</a> * <span class="type-var">'result</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span> <span class="xref-unresolved">Lwt</span>.t</span></span></code></div><div class="spec-doc"><p><code>verify t f</code> runs <code>f</code> in checking mode, loading data from the proof as needed.</p><p>When the result is <code>Ok (t, r)</code>, <code>t</code> is the generated tree after <code>f</code> has completed and <code>r</code> is the result of the computation. More operations can be run on <code>t</code>, but it won't be able to access the underlying storage and will raise <code>Dangling_hash</code> when trying to read unloaded parts of <code>t</code>.</p><p>When the result is <code>Error msg</code>, the proof is rejected.</p></div></div><div class="odoc-spec"><div class="spec type subst" id="type-tree_proof" class="anchored"><a href="#type-tree_proof" class="anchor"></a><code><span><span class="keyword">type</span> tree_proof</span><span> := <span><a href="Proof/index.html#type-tree">Proof.tree</a> <a href="Proof/index.html#type-t">Proof.t</a></span></span></code></div><div class="spec-doc"><p>The type for tree proofs.</p><p>Guarantee that the given computation performs exactly the same state operations as the generating computation, *in some order*.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-produce_proof" class="anchored"><a href="#val-produce_proof" class="anchor"></a><code><span><span class="keyword">val</span> produce_proof : <span><span>(<a href="#type-tree_proof">tree_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-producer">producer</a></span></span></code></div><div class="spec-doc"><p><code>produce_proof</code> is the producer of tree proofs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-verify_proof" class="anchored"><a href="#val-verify_proof" class="anchor"></a><code><span><span class="keyword">val</span> verify_proof : <span><span>(<a href="#type-tree_proof">tree_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-verifier">verifier</a></span></span></code></div><div class="spec-doc"><p><code>verify_proof</code> is the verifier of tree proofs.</p></div></div><div class="odoc-spec"><div class="spec type subst" id="type-stream_proof" class="anchored"><a href="#type-stream_proof" class="anchor"></a><code><span><span class="keyword">type</span> stream_proof</span><span> := <span><a href="Proof/index.html#type-stream">Proof.stream</a> <a href="Proof/index.html#type-t">Proof.t</a></span></span></code></div><div class="spec-doc"><p>The type for stream proofs.</p><p>Guarantee that the given computation performs exactly the same state operations as the generating computation, in the exact same order.*in some order*.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-produce_stream" class="anchored"><a href="#val-produce_stream" class="anchor"></a><code><span><span class="keyword">val</span> produce_stream : <span><span>(<a href="#type-stream_proof">stream_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-producer">producer</a></span></span></code></div><div class="spec-doc"><p><code>produce_stream</code> is the producer of stream proofs.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-verify_stream" class="anchored"><a href="#val-verify_stream" class="anchor"></a><code><span><span class="keyword">val</span> verify_stream : <span><span>(<a href="#type-stream_proof">stream_proof</a>, <span class="type-var">'a</span>)</span> <a href="#type-verifier">verifier</a></span></span></code></div><div class="spec-doc"><p><code>verify_stream</code> is the verifier of stream proofs.</p></div></div></div></body></html>