<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ao (irmin-pack.Irmin_pack_unix.Chunked_suffix.S.Ao)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">irmin-pack</a> &#x00BB; <a href="../../../index.html">Irmin_pack_unix</a> &#x00BB; <a href="../../index.html">Chunked_suffix</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; Ao</nav><header class="odoc-preamble"><h1>Module <code><span>S.Ao</span></code></h1><p>Abstraction for irmin-pack's append only files (i.e. suffix and dict).</p><p>It is parameterized with <code>Io</code>, a file system abstraction (e.g. unix, mirage, eio_linux).</p><p>It comprises a persistent file, an append buffer and take care of automatically shifting offsets to deal with legacy file headers.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Io"><a href="#module-Io" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Io/index.html">Io</a></span><span> : <a href="../../../Io/module-type-S/index.html">Io.S</a></span></code></div><div class="spec-doc"><p>Low level IO abstraction. A typical implementation is unix. This abstraction is meant to be dead simple. Not a lot of documentation is required.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Errs"><a href="#module-Errs" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Errs/index.html">Errs</a></span><span> : <a href="../../../Io_errors/module-type-S/index.html">Io_errors.S</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-auto_flush_procedure"><a href="#type-auto_flush_procedure" class="anchor"></a><code><span><span class="keyword">type</span> auto_flush_procedure</span><span> = </span><span>[ </span></code><ol><li id="type-auto_flush_procedure.Internal" class="def constructor anchored"><a href="#type-auto_flush_procedure.Internal" class="anchor"></a><code><span>| </span></code><code><span>`Internal</span></code></li><li id="type-auto_flush_procedure.External" class="def constructor anchored"><a href="#type-auto_flush_procedure.External" class="anchor"></a><code><span>| </span></code><code><span>`External <span class="keyword">of</span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p><code>auto_flush_procedure</code> defines behavior when the flush threshold is reached.</p><ul><li>Use <code>`Internal</code> to have the buffer automatically flushed.</li><li>Use <code>`External f</code> to have <code>f</code> called when the flush threshold is reached. It is the responsibility of <code>f</code> to call flush, in addition to any other processing it does.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_rw"><a href="#val-create_rw" class="anchor"></a><code><span><span class="keyword">val</span> create_rw : 
  <span>path:string <span class="arrow">&#45;&gt;</span></span>
  <span>overwrite:bool <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_threshold:int <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_procedure:<a href="#type-auto_flush_procedure">auto_flush_procedure</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>, <span>[&gt; <a href="Io/index.html#type-create_error">Io.create_error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Create a rw instance of <code>t</code> by creating the file at <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_rw"><a href="#val-open_rw" class="anchor"></a><code><span><span class="keyword">val</span> open_rw : 
  <span>path:string <span class="arrow">&#45;&gt;</span></span>
  <span>end_poff:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span>dead_header_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_threshold:int <span class="arrow">&#45;&gt;</span></span>
  <span>auto_flush_procedure:<a href="#type-auto_flush_procedure">auto_flush_procedure</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>,
    <span>[&gt; <a href="Io/index.html#type-open_error">Io.open_error</a>
    <span>| `Closed</span>
    <span>| `Invalid_argument</span>
    <span>| `Read_out_of_bounds</span>
    <span>| `Inconsistent_store</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Create a rw instance of <code>t</code> by opening an existing file at <code>path</code>.</p><p>End Offset</p><p>The file has an end offset at which new data will be saved. While this information could be computed by looking at the size of the file, we prefer storing that information elsewhere (i.e. in the control file). This is why <code>open_rw</code> and <code>open_ro</code> take an <code>end_poff</code> parameter, and also why <code>refresh_end_poff</code> exists. The abstractions above <code>Append_only_file</code> are responsible for reading/writing the offsets from/to the control file.</p><p><code>dead_header_size</code></p><p>Designates a small area at the beginning of the file that should be ignored. The offsets start after that area.</p><p>The actual persisted size of a file is <code>end_poff + dead_header_size</code>.</p><p>This concept exists in order to keep supporting <code>`V1</code> and <code>`V2</code> pack stores with <code>`V3</code>.</p><p>Auto Flushes</p><p>One of the goals of the <code>Append_only_file</code> abstraction is to provide buffered appends. <code>auto_flush_threshold</code> is the soft cap after which the buffer should be flushed. When a call to <code>append_exn</code> fills the buffer, either the buffer will be flushed automatically, if <code>auto_flush_procedure = `Internal</code>, or the supplied external function <code>f</code> will be called, if <code>auto_flush_procedure = `External f</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-open_ro"><a href="#val-open_ro" class="anchor"></a><code><span><span class="keyword">val</span> open_ro : 
  <span>path:string <span class="arrow">&#45;&gt;</span></span>
  <span>end_poff:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span>dead_header_size:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-t">t</a>,
    <span>[&gt; <a href="Io/index.html#type-open_error">Io.open_error</a>
    <span>| `Closed</span>
    <span>| `Inconsistent_store</span>
    <span>| `Invalid_argument</span>
    <span>| `Read_out_of_bounds</span> ]</span>)</span>
    <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Create a ro instance of <code>t</code> by opening an existing file at <code>path</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-close"><a href="#val-close" class="anchor"></a><code><span><span class="keyword">val</span> close : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span>[&gt; <a href="Io/index.html#type-close_error">Io.close_error</a> <span>| `Pending_flush</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Close the underlying file.</p><p>The internal buffer is expected to be in a flushed state when <code>close</code> is called. Otherwise, an error is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-end_poff"><a href="#val-end_poff" class="anchor"></a><code><span><span class="keyword">val</span> end_poff : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Optint</span>.Int63.t</span></code></div><div class="spec-doc"><p><code>end_poff t</code> is the number of bytes of the file. That function doesn't perform IO.</p><p>RW mode</p><p>It also counts the bytes not flushed yet.</p><p>RO mode</p><p>This information originates from the latest reload of the control file. Calling <code>refresh_end_poff t</code> updates <code>end_poff</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_to_string"><a href="#val-read_to_string" class="anchor"></a><code><span><span class="keyword">val</span> read_to_string : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>off:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span>len:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string, <span>[&gt; <a href="Io/index.html#type-read_error">Io.read_error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-read_exn"><a href="#val-read_exn" class="anchor"></a><code><span><span class="keyword">val</span> read_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>off:<span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span> <span>len:int <span class="arrow">&#45;&gt;</span></span> <span>bytes <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>read_exn t ~off ~len b</code> puts the <code>len</code> bytes of <code>t</code> at <code>off</code> to <code>b</code>.</p><p><code>read_to_string</code> should always be favored over <code>read_exn</code>, except when performences matter.</p><p>It is not possible to read from an offset further than <code>end_poff t</code>.</p><p>Raises <code>Io.Read_error</code> and <code>Errors.Pack_error `Read_out_of_bounds</code>.</p><p>RW mode</p><p>Attempting to read from the append buffer results in an <code>`Read_out_of_bounds</code> error. This feature could easily be implemented in the future if ever needed. It was not needed with io_legacy.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-append_exn"><a href="#val-append_exn" class="anchor"></a><code><span><span class="keyword">val</span> append_exn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>append_exn t ~off b</code> writes <code>b</code> to the end of <code>t</code>. Might trigger an auto flush.</p><p>Grows <code>end_poff</code>, but the parent abstraction is expected to persist this somewhere (e.g. in the control file).</p><p>Post-condition: <code>end_poff t - end_poff (old t) = String.length b</code>.</p><p>Raises <code>Io.Write_error</code></p><p>RW mode</p><p>Always raises <code>Errors.RO_not_allowed</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span><span class="keyword">val</span> flush : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span>[&gt; <a href="Io/index.html#type-write_error">Io.write_error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Flush the append buffer. Does not call <code>fsync</code>.</p><p>RO mode</p><p>Always returns <code>Error `Ro_not_allowed</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fsync"><a href="#val-fsync" class="anchor"></a><code><span><span class="keyword">val</span> fsync : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <span>[&gt; <a href="Io/index.html#type-write_error">Io.write_error</a> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Tell the os to fush its internal buffers. Does not call <code>flush</code>.</p><p>RO mode</p><p>Always returns <code>Error `Ro_not_allowed</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-refresh_end_poff"><a href="#val-refresh_end_poff" class="anchor"></a><code><span><span class="keyword">val</span> refresh_end_poff : 
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Optint</span>.Int63.t <span class="arrow">&#45;&gt;</span></span>
  <span><span>(unit, <span>[&gt; `Rw_not_allowed ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Ingest the new end offset of the file. Typically happens in RO mode when the control file has been re-read.</p><p>RW mode</p><p>Always returns <code>Error `Rw_not_allowed</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-readonly"><a href="#val-readonly" class="anchor"></a><code><span><span class="keyword">val</span> readonly : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-auto_flush_threshold"><a href="#val-auto_flush_threshold" class="anchor"></a><code><span><span class="keyword">val</span> auto_flush_threshold : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty_buffer"><a href="#val-empty_buffer" class="anchor"></a><code><span><span class="keyword">val</span> empty_buffer : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path"><a href="#val-path" class="anchor"></a><code><span><span class="keyword">val</span> path : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div></div></body></html>