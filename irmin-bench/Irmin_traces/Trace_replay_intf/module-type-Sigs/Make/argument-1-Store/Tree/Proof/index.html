<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Proof (irmin-bench.Irmin_traces.Trace_replay_intf.Sigs.Make.1-Store.Tree.Proof)</title><link rel="stylesheet" href="../../../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../../../../index.html">irmin-bench</a> &#x00BB; <a href="../../../../../../index.html">Irmin_traces</a> &#x00BB; <a href="../../../../../index.html">Trace_replay_intf</a> &#x00BB; <a href="../../../../index.html">Sigs</a> &#x00BB; <a href="../../../index.html">Make</a> &#x00BB; <a href="../../index.html">1-Store</a> &#x00BB; <a href="../index.html">Tree</a> &#x00BB; Proof</nav><header class="odoc-preamble"><h1>Module <code><span>Tree.Proof</span></code></h1></header><div class="odoc-content"><div class="odoc-include"><div class="odoc-spec"><div class="spec type" id="type-kinded_hash" class="anchored"><a href="#type-kinded_hash" class="anchor"></a><code><span><span class="keyword">type</span> kinded_hash</span><span> = </span><span>[ </span></code><table><tr id="type-kinded_hash.Contents" class="anchored"><td class="def constructor"><a href="#type-kinded_hash.Contents" class="anchor"></a><code><span>| </span></code><code><span>`Contents <span class="keyword">of</span> <a href="../../index.html#type-hash">hash</a> * <a href="../../index.html#type-metadata">metadata</a></span></code></td></tr><tr id="type-kinded_hash.Node" class="anchored"><td class="def constructor"><a href="#type-kinded_hash.Node" class="anchor"></a><code><span>| </span></code><code><span>`Node <span class="keyword">of</span> <a href="../../index.html#type-hash">hash</a></span></code></td></tr></table><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-kinded_hash_t" class="anchored"><a href="#val-kinded_hash_t" class="anchor"></a><code><span><span class="keyword">val</span> kinded_hash_t : <span><a href="#type-kinded_hash">kinded_hash</a> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-inode" class="anchored"><a href="#type-inode" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a inode</span></span><span> = </span><span>{</span></code><table><tr id="type-inode.length" class="anchored"><td class="def record field"><a href="#type-inode.length" class="anchor"></a><code><span>length : int;</span></code></td></tr><tr id="type-inode.proofs" class="anchored"><td class="def record field"><a href="#type-inode.proofs" class="anchor"></a><code><span>proofs : <span><span>(int * <span class="type-var">'a</span>)</span> list</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type for (internal) inode proofs.</p><p>These proofs encode large directories into a tree-like structure.</p><p>Invariants are dependent on the backend.</p><p><code>length</code> is the total number of entries in the children of the inode. It's the size of the &quot;flattened&quot; version of that inode. <code>length</code> can be used to prove the correctness of operations such as <code>Tree.length</code> and <code>Tree.list ~offset ~length</code> in an efficient way.</p><p><code>proofs</code> contains the children proofs. It is a sparse list of <code>'a</code> values. These values are associated to their index in the list, and the list is kept sorted in increasing order of indices. <code>'a</code> can be a concrete proof or a hash of that proof.</p><p><em>For <code>irmin-pack</code></em>: <code>proofs</code> have a length of at most <code>Conf.entries</code> entries. For binary trees, this boolean index is a step of the left-right sequence / decision proof corresponding to the path in that binary tree.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inode_t" class="anchored"><a href="#val-inode_t" class="anchor"></a><code><span><span class="keyword">val</span> inode_t : <span><span><span class="type-var">'a</span> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-inode">inode</a></span> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-inode_extender" class="anchored"><a href="#type-inode_extender" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a inode_extender</span></span><span> = </span><span>{</span></code><table><tr id="type-inode_extender.length" class="anchored"><td class="def record field"><a href="#type-inode_extender.length" class="anchor"></a><code><span>length : int;</span></code></td></tr><tr id="type-inode_extender.segments" class="anchored"><td class="def record field"><a href="#type-inode_extender.segments" class="anchor"></a><code><span>segments : <span>int list</span>;</span></code></td></tr><tr id="type-inode_extender.proof" class="anchored"><td class="def record field"><a href="#type-inode_extender.proof" class="anchor"></a><code><span>proof : <span class="type-var">'a</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The type for inode extenders.</p><p>An extender is a compact representation of a sequence of <code>inode</code> which contain only one child. As for inodes, the <code>'a</code> parameter can be a concrete proof or a hash of that proof.</p><p>If an inode proof contains singleton children <code>i_0, ..., i_n</code> such as: <code>{length=l; proofs = [ (i_0, {proofs = ... { proofs = [ (i_n, p) ] }})]}</code>, then it is compressed into the inode extender <code>{length=l; segment = [i_0;..;i_n]; proof=p}</code> sharing the same length <code>l</code> and final proof <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-inode_extender_t" class="anchored"><a href="#val-inode_extender_t" class="anchor"></a><code><span><span class="keyword">val</span> inode_extender_t : <span><span><span class="type-var">'a</span> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-inode_extender">inode_extender</a></span> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-tree" class="anchored"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> tree</span><span> = </span></code><table><tr id="type-tree.Contents" class="anchored"><td class="def variant constructor"><a href="#type-tree.Contents" class="anchor"></a><code><span>| </span><span><span class="constructor">Contents</span> <span class="keyword">of</span> <a href="../../index.html#type-contents">contents</a> * <a href="../../index.html#type-metadata">metadata</a></span></code></td></tr><tr id="type-tree.Blinded_contents" class="anchored"><td class="def variant constructor"><a href="#type-tree.Blinded_contents" class="anchor"></a><code><span>| </span><span><span class="constructor">Blinded_contents</span> <span class="keyword">of</span> <a href="../../index.html#type-hash">hash</a> * <a href="../../index.html#type-metadata">metadata</a></span></code></td></tr><tr id="type-tree.Node" class="anchored"><td class="def variant constructor"><a href="#type-tree.Node" class="anchor"></a><code><span>| </span><span><span class="constructor">Node</span> <span class="keyword">of</span> <span><span>(<a href="../../index.html#type-step">step</a> * <a href="#type-tree">tree</a>)</span> list</span></span></code></td></tr><tr id="type-tree.Blinded_node" class="anchored"><td class="def variant constructor"><a href="#type-tree.Blinded_node" class="anchor"></a><code><span>| </span><span><span class="constructor">Blinded_node</span> <span class="keyword">of</span> <a href="../../index.html#type-hash">hash</a></span></code></td></tr><tr id="type-tree.Inode" class="anchored"><td class="def variant constructor"><a href="#type-tree.Inode" class="anchor"></a><code><span>| </span><span><span class="constructor">Inode</span> <span class="keyword">of</span> <span><a href="#type-inode_tree">inode_tree</a> <a href="#type-inode">inode</a></span></span></code></td></tr><tr id="type-tree.Extender" class="anchored"><td class="def variant constructor"><a href="#type-tree.Extender" class="anchor"></a><code><span>| </span><span><span class="constructor">Extender</span> <span class="keyword">of</span> <span><a href="#type-inode_tree">inode_tree</a> <a href="#type-inode_extender">inode_extender</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>The type for compressed and partial Merkle tree proofs.</p><p>Tree proofs do not provide any guarantee with the ordering of computations. For instance, if two effects commute, they won't be distinguishable by this kind of proof.</p><p><code>Value v</code> proves that a value <code>v</code> exists in the store.</p><p><code>Blinded_value h</code> proves a value with hash <code>h</code> exists in the store.</p><p><code>Node ls</code> proves that a a &quot;flat&quot; node containing the list of files <code>ls</code> exists in the store. <em>For <code>irmin-pack</code></em>: the length of <code>ls</code> is at most <code>Conf.stable_hash</code>;</p><p><code>Blinded_node h</code> proves that a node with hash <code>h</code> exists in the store.</p><p><code>Inode i</code> proves that an inode <code>i</code> exists in the store.</p><p><code>Extender e</code> proves that an inode extender <code>e</code> exist in the store.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-inode_tree" class="anchored"><a href="#type-inode_tree" class="anchor"></a><code><span><span class="keyword">and</span> inode_tree</span><span> = </span></code><table><tr id="type-inode_tree.Blinded_inode" class="anchored"><td class="def variant constructor"><a href="#type-inode_tree.Blinded_inode" class="anchor"></a><code><span>| </span><span><span class="constructor">Blinded_inode</span> <span class="keyword">of</span> <a href="../../index.html#type-hash">hash</a></span></code></td></tr><tr id="type-inode_tree.Inode_values" class="anchored"><td class="def variant constructor"><a href="#type-inode_tree.Inode_values" class="anchor"></a><code><span>| </span><span><span class="constructor">Inode_values</span> <span class="keyword">of</span> <span><span>(<a href="../../index.html#type-step">step</a> * <a href="#type-tree">tree</a>)</span> list</span></span></code></td></tr><tr id="type-inode_tree.Inode_tree" class="anchored"><td class="def variant constructor"><a href="#type-inode_tree.Inode_tree" class="anchor"></a><code><span>| </span><span><span class="constructor">Inode_tree</span> <span class="keyword">of</span> <span><a href="#type-inode_tree">inode_tree</a> <a href="#type-inode">inode</a></span></span></code></td></tr><tr id="type-inode_tree.Inode_extender" class="anchored"><td class="def variant constructor"><a href="#type-inode_tree.Inode_extender" class="anchor"></a><code><span>| </span><span><span class="constructor">Inode_extender</span> <span class="keyword">of</span> <span><a href="#type-inode_tree">inode_tree</a> <a href="#type-inode_extender">inode_extender</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>The type for inode trees. It is a subset of <code>tree</code>, limited to nodes.</p><p><code>Blinded_inode h</code> proves that an inode with hash <code>h</code> exists in the store.</p><p><code>Inode_values ls</code> is simliar to trees' <code>Node</code>.</p><p><code>Inode_tree i</code> is similar to tree's <code>Inode</code>.</p><p><code>Inode_extender e</code> is similar to trees' <code>Extender</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tree_t" class="anchored"><a href="#val-tree_t" class="anchor"></a><code><span><span class="keyword">val</span> tree_t : <span><a href="#type-tree">tree</a> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-inode_tree_t" class="anchored"><a href="#val-inode_tree_t" class="anchor"></a><code><span><span class="keyword">val</span> inode_tree_t : <span><a href="#type-inode_tree">inode_tree</a> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><p>Stream proofs represent an explicit traversal of a Merle tree proof. Every element (a node, a value, or a shallow pointer) met is first &quot;compressed&quot; by shallowing its children and then recorded in the proof.</p><p>As stream proofs directly encode the recursive construction of the Merkle root hash is slightly simpler to implement: the verifier simply needs to hash the compressed elements lazily, without any memory or choice.</p><p>Moreover, the minimality of stream proofs is trivial to check. Once the computation has consumed the compressed elements required, it is sufficient to check that no more compressed elements remain in the proof.</p><p>However, as the compressed elements contain all the hashes of their shallow children, the size of stream proofs is larger (at least double in size in practice) than tree proofs, which only contains the hash for intermediate shallow pointers.</p><div class="odoc-spec"><div class="spec type" id="type-elt" class="anchored"><a href="#type-elt" class="anchor"></a><code><span><span class="keyword">type</span> elt</span><span> = </span></code><table><tr id="type-elt.Contents" class="anchored"><td class="def variant constructor"><a href="#type-elt.Contents" class="anchor"></a><code><span>| </span><span><span class="constructor">Contents</span> <span class="keyword">of</span> <a href="../../index.html#type-contents">contents</a></span></code></td></tr><tr id="type-elt.Node" class="anchored"><td class="def variant constructor"><a href="#type-elt.Node" class="anchor"></a><code><span>| </span><span><span class="constructor">Node</span> <span class="keyword">of</span> <span><span>(<a href="../../index.html#type-step">step</a> * <a href="#type-kinded_hash">kinded_hash</a>)</span> list</span></span></code></td></tr><tr id="type-elt.Inode" class="anchored"><td class="def variant constructor"><a href="#type-elt.Inode" class="anchor"></a><code><span>| </span><span><span class="constructor">Inode</span> <span class="keyword">of</span> <span><a href="../../index.html#type-hash">hash</a> <a href="#type-inode">inode</a></span></span></code></td></tr><tr id="type-elt.Inode_extender" class="anchored"><td class="def variant constructor"><a href="#type-elt.Inode_extender" class="anchor"></a><code><span>| </span><span><span class="constructor">Inode_extender</span> <span class="keyword">of</span> <span><a href="../../index.html#type-hash">hash</a> <a href="#type-inode_extender">inode_extender</a></span></span></code></td></tr></table></div><div class="spec-doc"><p>The type for elements of stream proofs.</p><p><code>Value v</code> is a proof that the next element read in the store is the value <code>v</code>.</p><p><code>Node n</code> is a proof that the next element read in the store is the node <code>n</code>.</p><p><code>Inode i</code> is a proof that the next element read in the store is the inode <code>i</code>.</p><p><code>Inode_extender e</code> is a proof that the next element read in the store is the node extender <code>e</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-elt_t" class="anchored"><a href="#val-elt_t" class="anchor"></a><code><span><span class="keyword">val</span> elt_t : <span><a href="#type-elt">elt</a> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-stream" class="anchored"><a href="#type-stream" class="anchor"></a><code><span><span class="keyword">type</span> stream</span><span> = <span><a href="#type-elt">elt</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p>The type for stream proofs.</p><p>The sequance <code>e_1 ... e_n</code> proves that the <code>e_1</code>, ..., <code>e_n</code> are read in the store in sequence.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stream_t" class="anchored"><a href="#val-stream_t" class="anchor"></a><code><span><span class="keyword">val</span> stream_t : <span><a href="#type-stream">stream</a> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>The type for proofs of kind <code>'a</code> (i.e. <code>stream</code> or <code>proof</code>).</p><p>A proof <code>p</code> proves that the state advanced from <code>before p</code> to <code>after p</code>. <code>state p</code>'s hash is <code>before p</code>, and <code>state p</code> contains the minimal information for the computation to reach <code>after p</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-t" class="anchored"><a href="#val-t" class="anchor"></a><code><span><span class="keyword">val</span> t : <span><span><span class="type-var">'a</span> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <a href="../../../../../../../../irmin/Irmin/Type/index.html#type-t">Irmin.Type.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-v" class="anchored"><a href="#val-v" class="anchor"></a><code><span><span class="keyword">val</span> v : <span>before:<a href="#type-kinded_hash">kinded_hash</a> <span class="arrow">&#45;&gt;</span></span> <span>after:<a href="#type-kinded_hash">kinded_hash</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>v ~before ~after p</code> proves that the state advanced from <code>before</code> to <code>after</code>. <code>p</code>'s hash is <code>before</code>, and <code>p</code> contains the minimal information for the computation to reach <code>after</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-before" class="anchored"><a href="#val-before" class="anchor"></a><code><span><span class="keyword">val</span> before : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-kinded_hash">kinded_hash</a></span></code></div><div class="spec-doc"><p><code>before t</code> it the state's hash at the beginning of the computation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-after" class="anchored"><a href="#val-after" class="anchor"></a><code><span><span class="keyword">val</span> after : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-kinded_hash">kinded_hash</a></span></code></div><div class="spec-doc"><p><code>after t</code> is the state's hash at the end of the computation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-state" class="anchored"><a href="#val-state" class="anchor"></a><code><span><span class="keyword">val</span> state : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>proof t</code> is a subset of the initial state needed to prove that the proven computation could run without performing any I/O.</p></div></div></div><div class="odoc-spec"><div class="spec value" id="val-to_tree" class="anchored"><a href="#val-to_tree" class="anchor"></a><code><span><span class="keyword">val</span> to_tree : <span><span><a href="#type-tree">tree</a> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../../index.html#type-tree">tree</a></span></code></div><div class="spec-doc"><p><code>to_tree p</code> is the tree <code>t</code> representing the tree proof <code>p</code>. Blinded parts of the proof will raise <code>Dangling_hash</code> when traversed.</p></div></div></div></body></html>