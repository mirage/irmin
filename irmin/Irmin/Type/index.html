<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type (irmin.Irmin.Type)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">irmin</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Irmin.Type</span></h1></header><div class="doc"><p>Dynamic types for Irmin values.</p></div><p>Yet-an-other type combinator library</p><p><code class="code">Type</code> provides type combinators to define runtime
representation for OCaml types and <a href="index.html#generics">generic
operations</a> to manipulate values with a runtime type
representation.</p><p>The type combinators supports all the usual <a href="index.html#primitives">type
primitives</a> but also compact definitions of <a href="index.html#records">records</a>
and <a href="index.html#variants">variants</a>. It also allows to define the runtime
representation of <a href="index.html#recursive">recursive types</a>.</p><h2>Type Combinators</h2><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a t</code><code></code><code></code></div><div class="doc"><p>The type for runtime representation of values of type <code class="code">'a</code>.</p></div></div><h2 id="primitives" class="anchored"><a href="#primitives" class="anchor"></a>Primitives</h2><div class="spec val" id="val-unit"><a href="#val-unit" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>unit : unit <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">unit</code> is a representation of the unit type.</p></div></div><div class="spec val" id="val-bool"><a href="#val-bool" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>bool : bool <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">bool</code> is a representation of the boolean type.</p></div></div><div class="spec val" id="val-char"><a href="#val-char" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>char : char <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">char</code> is a representation of the character type.</p></div></div><div class="spec val" id="val-int32"><a href="#val-int32" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>int32 : int32 <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">int32</code> is a representation of the 32-bit integers type.</p></div></div><div class="spec val" id="val-int64"><a href="#val-int64" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>int64 : int64 <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">int64</code> is a representation of the 64-bit integer type.</p></div></div><div class="spec val" id="val-float"><a href="#val-float" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>float : float <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">float</code> is a representation of the float type.</p></div></div><div class="spec val" id="val-string"><a href="#val-string" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>string : string <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">string</code> is a representation of the string type.</p></div></div><div class="spec val" id="val-cstruct"><a href="#val-cstruct" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cstruct : Cstruct.t <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">cstruct</code> is a representation of the <code class="code">Cstruct.t</code> type.</p></div></div><div class="spec val" id="val-list"><a href="#val-list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">list t</code> is a representation of list of values of type <code class="code">t</code>.</p></div></div><div class="spec val" id="val-array"><a href="#val-array" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> array <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">array t</code> is a representation of array of values of type <code class="code">t</code>.</p></div></div><div class="spec val" id="val-option"><a href="#val-option" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>option : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">option t</code> is a representation of value of type <code class="code">t option</code>.</p></div></div><div class="spec val" id="val-pair"><a href="#val-pair" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pair : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">pair x y</code> is a representation of values of type <code class="code">x * y</code>.</p></div></div><div class="spec val" id="val-triple"><a href="#val-triple" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>triple : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">triple x y z</code> is a representation of values of type <code class="code">x * y *
      z</code>.</p></div></div><div class="spec val" id="val-result"><a href="#val-result" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>result : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>) Result.result <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">result a b</code> is a representation of values of type <code class="code">(a, b)
      result</code>.</p></div></div><h2 id="records" class="anchored"><a href="#records" class="anchor"></a>Records</h2><div class="spec type" id="type-field"><a href="#type-field" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('a, 'b) field</code><code></code><code></code></div><div class="doc"><p>The type for fields holding values of type <code class="code">'b</code> and belonging to a
record of type <code class="code">'a</code>.</p></div></div><div class="spec val" id="val-field"><a href="#val-field" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>field : string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'b</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'b</span>, <span class="type-var">'a</span>) <a href="index.html#type-field">field</a></code></div><div class="doc"><p><code class="code">field n t g</code> is the representation of the field <code class="code">n</code> of type <code class="code">t</code>
with getter <code class="code">g</code>.</p><p>For instance:</p><pre><code class="code">        type t = { foo: string option }

        let foo = field &quot;foo&quot; (option string) (fun t -&gt; t.foo)</code></pre></div></div><div class="spec type" id="type-open_record"><a href="#type-open_record" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('a, 'b, 'c) open_record</code><code></code><code></code></div><div class="doc"><p>The type for representing open records of type <code class="code">'a</code> with
constructors of type <code class="code">'b</code>. <code class="code">'c</code> represents the fields missings to
the record, e.g. an open record initially holds <code class="code">'c = 'b</code> and it
can can be <a href="index.html#val-sealr">sealed</a> when <code class="code">'c = 'a</code>.</p></div></div><div class="spec val" id="val-sealr"><a href="#val-sealr" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sealr : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span>) <a href="index.html#type-open_record">open_record</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">sealr r</code> seal the open record <code class="code">r</code>.</p></div></div><div class="spec val" id="val-(|+)"><a href="#val-(|+)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(|+) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'d</span>) <a href="index.html#type-open_record">open_record</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-field">field</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>) <a href="index.html#type-open_record">open_record</a></code></div><div class="doc"><p><code class="code">r |+ f</code> adds the field <code class="code">f</code> to the open record <code class="code">r</code>.</p></div></div><div class="spec val" id="val-record"><a href="#val-record" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>record : string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>) <a href="index.html#type-open_record">open_record</a></code></div><div class="doc"><p><code class="code">record n f fs</code> is the representation of the record called <code class="code">n</code> of
type <code class="code">'a</code> using <code class="code">f</code> as constructor and with the fields <code class="code">fs</code>.</p><p>Putting all together:</p><pre><code class="code">        type t = { foo: string; bar: (int64 * string) list; }

        let t =
          record &quot;t&quot; (fun foo bar -&gt; { foo; bar })
          |+ field &quot;foo&quot; string (fun t -&gt; t.foo)
          |+ field &quot;bar&quot; (list (pair int64 string)) (fun t -&gt; t.bar)
          |&gt; sealr</code></pre></div></div><h2 id="variants" class="anchored"><a href="#variants" class="anchor"></a>Variants</h2><div class="spec type" id="type-case"><a href="#type-case" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('a, 'b) case</code><code></code><code></code></div><div class="doc"><p>The type for representing variant cases of type <code class="code">'a</code> with
patterns of type <code class="code">'b</code>.</p></div></div><div class="spec type" id="type-case_p"><a href="#type-case_p" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a case_p</code><code></code><code></code></div><div class="doc"><p>The type for representing patterns for a variant of type <code class="code">'a</code>.</p></div></div><div class="spec val" id="val-case0"><a href="#val-case0" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>case0 : string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a>) <a href="index.html#type-case">case</a></code></div><div class="doc"><p><code class="code">case0 n v</code> is a representation of a variant case <code class="code">n</code> with no
argument and a singleton pattern. e.g.</p><pre><code class="code">        type t = Foo

        let foo = case0 &quot;Foo&quot; Foo</code></pre></div></div><div class="spec val" id="val-case1"><a href="#val-case1" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>case1 : string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'b</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a>) <a href="index.html#type-case">case</a></code></div><div class="doc"><p><code class="code">case1 n t c</code> is a representation of a variant case <code class="code">n</code> with 1
argument of type <code class="code">t</code> and a pattern <code class="code">c</code> an function with one argument
of type <code class="code">t</code>. e.g.</p><pre><code class="code">        type t = Foo of string

        let foo = case1 &quot;Foo&quot; string (fun s -&gt; Foo s)</code></pre></div></div><div class="spec type" id="type-open_variant"><a href="#type-open_variant" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('a, 'b, 'c) open_variant</code><code></code><code></code></div><div class="doc"><p>The type for representing open variants of type <code class="code">'a</code> with pattern
matching of type <code class="code">'b</code>. <code class="code">'c</code> represents the missing cases for the
variant, e.g. initially variant hols <code class="code">c' = 'b</code> and it can be
<a href="index.html#val-sealv">sealed</a> when <code class="code">'c = 'a</code>.</p></div></div><div class="spec val" id="val-sealv"><a href="#val-sealv" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sealv : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-case_p">case_p</a>) <a href="index.html#type-open_variant">open_variant</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">sealv v</code> seals the open variant <code class="code">v</code>.</p></div></div><div class="spec val" id="val-(|~)"><a href="#val-(|~)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(|~) : (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'d</span>) <a href="index.html#type-open_variant">open_variant</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'c</span>) <a href="index.html#type-case">case</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'d</span>) <a href="index.html#type-open_variant">open_variant</a></code></div><div class="doc"><p><code class="code">v |~ c</code> is the map <code class="code">v</code> augmented with the case <code class="code">c</code>.</p></div></div><div class="spec val" id="val-variant"><a href="#val-variant" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>variant : string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'b</span>) <a href="index.html#type-open_variant">open_variant</a></code></div><div class="doc"><p><code class="code">variant n c p</code> is a representation of a variant type containing
the cases <code class="code">c</code> and using <code class="code">p</code> to deconstruct values.</p><p>Putting all together:</p><pre><code class="code">        type t = Foo | Bar of string

        let t =
          variant &quot;t&quot; (fun foo bar -&gt; function
              | Foo   -&gt; foo
              | Bar s -&gt; bar s)
          |~ case0 &quot;Foo&quot; Foo
          |~ case1 &quot;Bar&quot; string (fun x -&gt; Bar x)
          |&gt; sealr</code></pre></div></div><div class="spec val" id="val-enum"><a href="#val-enum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>enum : string <span class="keyword">&#8209;&gt;</span> (string<span class="keyword"> * </span><span class="type-var">'a</span>) list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">enum n l</code> is a representation of the variant type which has
only constant variant case. e.g.</p><pre><code class="code">        type t = Foo | Bar | Toto

        let t = enum &quot;t&quot; [&quot;Foo&quot;, Foo; &quot;Bar&quot;, Bar; &quot;Toto&quot;, Toto]</code></pre></div></div><h2 id="recursive" class="anchored"><a href="#recursive" class="anchor"></a>Recursive definitions</h2><p><code class="code">Type</code> allows to create a limited form of recursive records and
variants.</p><p><b>TODO</b>: describe the limitations, e.g. only regular recursion
and no use of the generics inside the <code class="code">mu*</code> functions and the
usual caveats with recursive values (such as infinite loops on
most of the generics which don't check sharing).</p><div class="spec val" id="val-mu"><a href="#val-mu" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mu : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">mu f</code> is the representation <code class="code">r</code> such that <code class="code">r = mu r</code>.</p><p>For instance:</p><pre><code class="code">        type x = { x: x option }

        let x = mu (fun x -&gt;
            record &quot;x&quot; (fun x -&gt; { x })
            |+ field &quot;x&quot; x (fun x -&gt; x.x)
            |&gt; sealr)</code></pre></div></div><div class="spec val" id="val-mu2"><a href="#val-mu2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mu2 : (<span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'b</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a><span class="keyword"> * </span><span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">mu2 f</code> is the representations <code class="code">r</code> and <code class="code">s</code> such that <code class="code">r, s = mu2 r
      s</code>.</p><p>For instance:</p><pre><code class="code">        type r = { foo: int; bar: string list; z: z option }
        and z = { x: int; r: r list }

        (* Build the representation of [r] knowing [z]'s. *)
        let mkr z =
          record &quot;r&quot; (fun foo bar z -&gt; { foo; bar; z })
          |+ field &quot;foo&quot; int (fun t -&gt; t.foo)
          |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
          |+ field &quot;z&quot; (option z) (fun t -&gt; t.z)
          |&gt; sealr

        (* And the representation of [z] knowing [r]'s. *)
        let mkz r =
          record &quot;z&quot; (fun x r -&gt; { x; r })
          |+ field &quot;x&quot; int (fun t -&gt; t.x)
          |+ field &quot;r&quot; (list r) (fun t -&gt; t.r)
          |&gt; sealr

        (* Tie the loop. *)
        let r, z = mu2 (fun r z -&gt; mkr z, mkz y)</code></pre></div></div><h2 id="proj" class="anchored"><a href="#proj" class="anchor"></a>Bijections</h2><p>Sometimes it is not always possible to describe precisely a type
(or it could be too tedious) and it is easier to describe the
relation with an other know type. This is what bijections are
about.</p><div class="spec val" id="val-like"><a href="#val-like" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>like : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span>) <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'b</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">like x f g</code> is the description of a type which looks like <code class="code">x</code>
using the bijetion <code class="code">(f, g)</code>.</p></div></div><h2 id="generics" class="anchored"><a href="#generics" class="anchor"></a>Generic Operations</h2><p>Given a value <code class="code">'a t</code>, it is possible to define generic operations
on value of type <code class="code">'a</code> such as pretty-printing, parsing and
unparsing.</p><div class="spec val" id="val-dump"><a href="#val-dump" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dump : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> Fmt.t</code></div><div class="doc"><p><code class="code">dump t</code> dumps the values of type <code class="code">t</code> as a parsable OCaml
expression.</p></div></div><div class="spec val" id="val-equal"><a href="#val-equal" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">equal t</code> is the equality function between values of type <code class="code">t</code>.</p></div></div><div class="spec val" id="val-compare"><a href="#val-compare" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">compare t</code> compares values of type <code class="code">t</code>.</p></div></div><h3>JSON converters</h3><div class="spec val" id="val-pp_json"><a href="#val-pp_json" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pp_json : ?&#8288;minify:bool <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> Fmt.t</code></div><div class="doc"><p>Similar to <a href="index.html#val-dump">dump</a> but pretty-prints the JSON representation instead
of the OCaml one. See <a href="index.html#val-encode_json">encode_json</a> for details about the encoding.</p><p>For instance:</p><pre><code class="code">        type t = { foo: int option; bar: string list };;

        let t =
          record &quot;r&quot; (fun foo bar -&gt; { foo; bar })
          |+ field &quot;foo&quot; (option int) (fun t -&gt; t.foo)
          |+ field &quot;bar&quot; (list string) (fun t -&gt; t.bar)
          |&gt; sealr

        let s = Fmt.strf &quot;%a\n&quot; (pp t) { foo = None; bar = [&quot;foo&quot;] }
        (* s is &quot;{ foo = None; bar = [\&quot;foo\&quot;]; }&quot; *)

        let j = Fmt.strf &quot;%a\n&quot; (pp_json t) { foo = None; bar = [&quot;foo&quot;] }
        (* j is &quot;{ \&quot;bar\&quot;:[\&quot;foo\&quot;] }&quot; *)</code></pre><p><b>NOTE:</b> this will automatically convert JSON fragments to valid
JSON objects by adding an enclosing array if necessary.</p></div></div><div class="spec val" id="val-encode_json"><a href="#val-encode_json" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>encode_json : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> Jsonm.encoder <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">encode_json t e</code> encodes <code class="code">t</code> into the
<a href="http://erratique.ch/software/jsonm">jsonm</a> encoder <code class="code">e</code>. The
encoding is a relatively straightforward translation of the OCaml
structure into JSON. The main highlights are:</p><ul><li>OCaml <code class="code">ints</code> are translated into JSON floats.</li><li>OCaml strings are translated into JSON strings. You must then
ensure that the OCaml strings contains only valid UTF-8
characters.</li><li>OCaml record fields of type <code class="code">'a option</code> are automatically
unboxed in their JSON representation. If the value if <code class="code">None</code>,
the field is removed from the JSON object.</li><li>variant cases built using <a href="index.html#val-case0">case0</a> are represented as strings.</li><li>variant cases built using <a href="index.html#val-case1">case1</a> are represented as a record
with one field; the field name is the name of the variant.</li></ul><p><b>NOTE:</b> this can be used to encode JSON fragments. That's the
responsibility of the caller to ensure that the encoded JSON
fragment fits properly into a well-formed JSON object.</p></div></div><div class="spec val" id="val-decode_json"><a href="#val-decode_json" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>decode_json : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> Jsonm.decoder <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, [ `Msg of string ]) Result.result</code></div><div class="doc"><p><code class="code">decode_json t e</code> decodes values of type <code class="code">t</code> from the
<a href="http://erratique.ch/software/jsonm">jsonm</a> decoder <code class="code">e</code>.</p></div></div><div class="spec val" id="val-decode_json_lexemes"><a href="#val-decode_json_lexemes" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>decode_json_lexemes : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> Jsonm.lexeme list <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, [ `Msg of string ]) Result.result</code></div><div class="doc"><p><code class="code">decode_json_lexemes</code> is similar to <a href="index.html#val-decode_json">decode_json</a> but use an
already decoded list of JSON lexemes instead of a decoder.</p></div></div><div class="spec val" id="val-encode_cstruct"><a href="#val-encode_cstruct" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>encode_cstruct : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> Cstruct.t</code></div><div class="doc"><p><code class="code">encode_cstruct t e</code> encodes <code class="code">t</code> into a `Cstruct.t`. The size of
the returned buffer is precomputed and the buffer is allocated
at once.</p><p><b>NOTE:</b> There is a special case when the parameter <code class="code">t</code> is a
single <code class="code">cstruct</code>: the original value is returned as is, without
being copied.</p></div></div><div class="spec val" id="val-decode_cstruct"><a href="#val-decode_cstruct" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>decode_cstruct : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> Cstruct.t <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span>, [ `Msg of string ]) Result.result</code></div><div class="doc"><p><code class="code">decode_cstruct t buf</code> decodes values of type <code class="code">t</code> as produced by
<code class="code">encode_cstruct t v</code>.</p><p><b>NOTE:</b> When the parameter <code class="code">t</code> is a single <code class="code">cstruct</code>, the
original buffer is returned as is, otherwise sub-<code class="code">cstruct</code> are
copied.</p></div></div></body></html>